<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>十二进制</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta property="og:type" content="website"><meta property="og:title" content="十二进制"><meta property="og:url" content="https://f-12.github.io/Hexo/page/2/index.html"><meta property="og:site_name" content="十二进制"><meta property="og:locale" content="default"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="十二进制"><link rel="alternate" href="/atom.xml" title="十二进制" type="application/atom+xml"><link rel="icon" href="/favicon.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/Hexo/css/style.css"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/Hexo/" id="logo">十二进制</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/Hexo/">Home</a> <a class="main-nav-link" href="/Hexo/archives">Archives</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="Search"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://f-12.github.io/Hexo"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-微服务监控告警——使用Prometheus构建监控Dashboard" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/Hexo/2019/04/23/微服务监控告警——使用Prometheus构建监控Dashboard/" class="article-date"><time datetime="2019-04-23T00:25:51.573Z" itemprop="datePublished">2019-04-23</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/Hexo/2019/04/23/微服务监控告警——使用Prometheus构建监控Dashboard/">微服务监控告警——使用Prometheus构建监控Dashboard</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="Metrics与可视化"><a href="#Metrics与可视化" class="headerlink" title="Metrics与可视化"></a>Metrics与可视化</h1><p>当谈及微服务监控时，实际上，监控的对象并不是微服务，而是微服务的metrics，即指标。</p><p>对于Metrics的监控，分为两个阶段：</p><ul><li><strong>Metrics收集阶段</strong></li><li><strong>Metrics可视化阶段</strong></li></ul></div><footer class="article-footer"><a data-url="https://f-12.github.io/Hexo/2019/04/23/微服务监控告警——使用Prometheus构建监控Dashboard/" data-id="cjvj9vo6w0004qex0r0qs42zr" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Monitoring/">Monitoring</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Prometheus/">Prometheus</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/微服务/">微服务</a></li></ul></footer></div></article><article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/Hexo/2019/04/20/hello-world/" class="article-date"><time datetime="2019-04-20T08:18:03.611Z" itemprop="datePublished">2019-04-20</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/Hexo/2019/04/20/hello-world/">Hello World</a></h1></header><div class="article-entry" itemprop="articleBody"><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p></div><footer class="article-footer"><a data-url="https://f-12.github.io/Hexo/2019/04/20/hello-world/" data-id="cjvj9vo6i0000qex0v1n3lq1t" class="article-share-link">Share</a></footer></div></article><article id="post-webpack的插件体系结构" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/Hexo/2017/09/25/webpack的插件体系结构/" class="article-date"><time datetime="2017-09-25T05:58:51.000Z" itemprop="datePublished">2017-09-25</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/Hexo/2017/09/25/webpack的插件体系结构/">webpack的插件体系结构</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><ol><li>javascript</li><li>webpack基本使用</li><li>node.js异步编程基础</li></ol><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><ul><li>webpack 1.13.2</li><li>node.js 6.9.5</li></ul><h1 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h1><ol><li>webpack</li><li>插件体系</li><li>Tapable.js</li></ol><hr><h1 id="正文内容"><a href="#正文内容" class="headerlink" title="正文内容"></a>正文内容</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>webpack概括来讲是一个打包工具，但也不仅仅是一个打包工具。这个从它复杂繁多的配置项里就可见一斑。webpack不仅能完成前端代码的打包，配合其他工具，它能做的事情几乎没有边界。配合babel完成es6到es5代码的转码，配合webpack-dev-server完成代码serve及开发时的hot-reload，配合uglify.js完成代码混淆，配合vue-loader转换<code>.vue</code>文件实现vue的单文件组件特性。而webpack完成这一强大扩展性的核心在于其基于<code>Tapable.js</code>的插件体系结构。<code>Tapable.js</code>本质上是一个发布-订阅模式的具体实现。</p><p>下面将从发布-订阅模式开始简要介绍webpack的插件结构。</p><h2 id="从发布-订阅模式谈起"><a href="#从发布-订阅模式谈起" class="headerlink" title="从发布-订阅模式谈起"></a>从发布-订阅模式谈起</h2><p>一个简单的发布-订阅模式中包括发布者，订阅者；发布者提供订阅方法和发布方法；订阅者提供发布回调方法。</p><h3 id="模拟一个简单的发布-订阅模式"><a href="#模拟一个简单的发布-订阅模式" class="headerlink" title="模拟一个简单的发布-订阅模式"></a>模拟一个简单的发布-订阅模式</h3><p>下面code展示了一个最简单的发布-订阅模式（推的形式）的实现。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布者，的管理节点，维护订阅者列表，发布具体数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Publisher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._subs = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅方法，callback是订阅者</span></span><br><span class="line">Publisher.prototype.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._subs.push(callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布方法, 发布者通过发布方法传递数据给订阅者</span></span><br><span class="line">Publisher.prototype.publish = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    sub(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅方法，发布者移除某个订阅者</span></span><br><span class="line">Publisher.prototype.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._subs = <span class="keyword">this</span>._subs.filter(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sub !== callback;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个简单模型里，因为javascript里函数也是对象，所以可以将订阅者和发布回调方法使用同一个callback函数实现。发布者还可以提供一个可选的取消订阅方法供客户代码取消特定订阅者，不再继续接受发布者发布的数据。</p><h3 id="浏览器中的发布-订阅模式"><a href="#浏览器中的发布-订阅模式" class="headerlink" title="浏览器中的发布-订阅模式"></a>浏览器中的发布-订阅模式</h3><p>真实环境中发布-订阅模式随处可见。</p><p>最常见的是浏览器里的事件机制。<code>EventTarget</code>是发布者，<code>EventTarget.prototype.addEventListener</code>是订阅方法，<code>EventTarget.prototype.dispatchEvent</code>是发布方法，<code>EventTarget.prototype.removeEventListener</code>是取消订阅方法。每一个继承了EventTarget的对象都是发布者。比较需要留意的是<code>Element</code>,<code>window</code>,<code>document</code>和<code>XMLHttpRequest</code>四个对象继承了<code>EventTarget</code>。</p><p>此外node.js的<code>EventEmitter</code>及继承了<code>EventEmitter</code>的对象也是发布者的实现。</p><h2 id="Tapable-js插件引擎"><a href="#Tapable-js插件引擎" class="headerlink" title="Tapable.js插件引擎"></a>Tapable.js插件引擎</h2><p>Tapable.js是webpack实现的一个插件引擎，本质上也是一个发布者的实现。每个Tapable类的实例都是一个发布者，内部维护了命名插件列表。同时Tapable类提供了一套管理订阅者的API，提供不同形式的调用发布回调方法。</p><p>作为webpack实现插件结构的基础类，我们有必要熟悉这个类提供的基础能力。下面将简要介绍Tapable.js的API的功能。</p><p>每个API通过一个代码块来描述，每个代码块包含四个部分：</p><ul><li>API的功能描述</li><li>API定义的方法签名</li><li>一段测试代码</li><li>测试代码的示例输出</li></ul><ol><li><p>Tapable类定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数， 初始化命名插件列表</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tapable</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册插件</span></span><br><span class="line">Tapable.prototype.plugin = <span class="function"><span class="keyword">function</span>(<span class="params">name, fn</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用插件，代理到插件实例的apply方法</span></span><br><span class="line">Tapable.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;      </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置同步插件列表开始下标</span></span><br><span class="line">Tapable.prototype.restartApplyPlugins</span><br></pre></td></tr></table></figure></li><li><p>applyPlugins</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用一个同步插件列表</span></span><br><span class="line">Tapable.prototype.applyPlugins = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码：</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPlugins'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPlugins'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 2'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPlugins'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 3'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.applyPlugins(<span class="string">'applyPlugins'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为</span></span><br><span class="line"><span class="comment">// this is plugin 1</span></span><br><span class="line"><span class="comment">// this is plugin 2</span></span><br><span class="line"><span class="comment">// this is plugin 3</span></span><br></pre></td></tr></table></figure></li><li><p>applyPluginsWaterfall</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用一个同步插件列表, 以init为初始值链式调用一个同步插件列表，列表中每个插件的返回值成为下一个插件的第一个参数</span></span><br><span class="line">Tapable.prototype.applyPluginsWaterfall = <span class="function"><span class="keyword">function</span>(<span class="params">name, init</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码：</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsWaterfall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 1'</span>, <span class="string">' i get value: '</span> + value++);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsWaterfall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 2'</span>, <span class="string">' i get value: '</span> + value++);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsWaterfall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 3'</span>, <span class="string">' i get value: '</span> + value++);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last = tapable.applyPluginsWaterfall(<span class="string">'applyPluginsWaterfall'</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'the last value: '</span> + last);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// this is plugin 1  i get value: 0</span></span><br><span class="line"><span class="comment">// this is plugin 2  i get value: 1</span></span><br><span class="line"><span class="comment">// this is plugin 3  i get value: 2</span></span><br><span class="line"><span class="comment">// the last value: 3</span></span><br></pre></td></tr></table></figure></li><li><p>applyPluginsBailResult</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用一个同步插件列表，第一个返回非undefinded的插件可提前返回</span></span><br><span class="line">Tapable.prototype.applyPluginsBailResult = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码：</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 2'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 3'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last = tapable.applyPluginsBailResult(<span class="string">'applyPluginsBailResult'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'the last value: '</span> + last);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为</span></span><br><span class="line"><span class="comment">// this is plugin 1</span></span><br><span class="line"><span class="comment">// this is plugin 2</span></span><br><span class="line"><span class="comment">// the last value: 2</span></span><br></pre></td></tr></table></figure></li><li><p>applyPluginsAsync</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用一个异步插件列表，上一个插件执行结束后执行下一个插件</span></span><br><span class="line">Tapable.prototype.applyPluginsAsync = functoin(name) &#123;&#125;</span><br><span class="line">Tapable.prototype.applyPluginsAsyncSeries = Tapable.prototype.applyPluginsAsync</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码：</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsAsync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 1 with delay: '</span> + delay );</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsAsync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 2 with delay: '</span> + delay );</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsAsync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 3 with delay: '</span> + delay );</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.applyPluginsAsync(<span class="string">'applyPluginsAsync'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// this is plugin 1 with delay: 365.28033813757423</span></span><br><span class="line"><span class="comment">// this is plugin 2 with delay: 615.922299406326</span></span><br><span class="line"><span class="comment">// this is plugin 3 with delay: 327.0493787299531</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure></li><li><p>applyPluginsAsyncWaterfall</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用一个异步插件列表，上一个插件执行结束后执行下一个插件，上一插件的值通过第一个参数传递到下一个插件</span></span><br><span class="line">Tapable.prototype.applyPluginsAsyncWaterfall = <span class="function"><span class="keyword">function</span>(<span class="params">name, init, callback</span>) </span>&#123;&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码:</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsAsyncWaterfall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 1 with delay: '</span> + delay );</span><br><span class="line">    callback(<span class="literal">null</span>, value + <span class="string">'-1'</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsAsyncWaterfall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 2 with delay: '</span> + delay );</span><br><span class="line">    callback(<span class="literal">null</span>, value + <span class="string">'-2'</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsAsyncWaterfall'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 3 with delay: '</span> + delay );</span><br><span class="line">    callback(<span class="literal">null</span>, value + <span class="string">'-3'</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.applyPluginsAsyncWaterfall(<span class="string">'applyPluginsAsyncWaterfall'</span>, <span class="string">'0'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'the last message: '</span> + message);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// this is plugin 1 with delay: 293.49776146010197</span></span><br><span class="line"><span class="comment">// this is plugin 2 with delay: 543.2495323181399</span></span><br><span class="line"><span class="comment">// this is plugin 3 with delay: 932.6130373949233</span></span><br><span class="line"><span class="comment">// the last message: 0-1-2-3</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure></li><li><p>applyPluginsParallel</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发调用一个异步插件列表，所有插件结束后返回</span></span><br><span class="line">Tapable.prototype.applyPluginsParallel = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码:</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totalDelay = <span class="number">0</span>;</span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsParallel'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 1 with delay: '</span> + delay );</span><br><span class="line">    totalDelay += delay;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsParallel'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 2 with delay: '</span> + delay );</span><br><span class="line">    totalDelay += delay;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsParallel'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is plugin 3 with delay: '</span> + delay );</span><br><span class="line">    totalDelay += delay;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.applyPluginsParallel(<span class="string">'applyPluginsParallel'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'totalDelay: '</span> + totalDelay);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// this is plugin 2 with delay: 45.88772912860905</span></span><br><span class="line"><span class="comment">// this is plugin 3 with delay: 353.1725171220388</span></span><br><span class="line"><span class="comment">// this is plugin 1 with delay: 491.4572602446987</span></span><br><span class="line"><span class="comment">// totalDelay: 890.5175064953467</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure></li><li><p>applyPluginsParallelBailResult</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并发调用一个异步插件列表，所有插件结束后返回, 返回最后一个有返回值的插件的返回值</span></span><br><span class="line">Tapable.prototype.applyPluginsParallelBailResult = <span class="function"><span class="keyword">function</span>(<span class="params">name, callback</span>) </span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于如下测试代码:</span></span><br><span class="line"><span class="keyword">var</span> tapable = <span class="keyword">new</span> Tapable();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> totalDelay = <span class="number">0</span>;</span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsParallelBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 1 with delay: '</span> + delay );</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    totalDelay += delay;</span><br><span class="line">    callback();</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsParallelBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 2 with delay: '</span> + delay );</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    totalDelay += delay;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin 2 returns at time: '</span>+ time);</span><br><span class="line">    callback(<span class="literal">null</span>, time);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.plugin(<span class="string">'applyPluginsParallelBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">1000</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this is plugin 3 with delay: '</span> + delay );</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    totalDelay += delay;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'plugin 3 returns at time: '</span>+ time);</span><br><span class="line">    callback(<span class="literal">null</span>, time);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tapable.applyPluginsParallelBailResult(<span class="string">'applyPluginsParallelBailResult'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'totalDelay: '</span> + totalDelay);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'the last value: '</span> + value);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'done'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为:</span></span><br><span class="line"><span class="comment">// this is plugin 1 with delay: 635.2381208798292</span></span><br><span class="line"><span class="comment">// this is plugin 2 with delay: 347.9609880914285</span></span><br><span class="line"><span class="comment">// this is plugin 3 with delay: 90.2209742134965</span></span><br><span class="line"><span class="comment">// plugin 3 returns at time: 1506257839951</span></span><br><span class="line"><span class="comment">// plugin 2 returns at time: 1506257840208</span></span><br><span class="line"><span class="comment">// totalDelay: 1073.4200831847543</span></span><br><span class="line"><span class="comment">// the last value: 1506257840208</span></span><br><span class="line"><span class="comment">// done</span></span><br></pre></td></tr></table></figure><p><strong><a href>获取Tapable.js测试代码</a></strong></p></li></ol><h2 id="wepack的插件结构"><a href="#wepack的插件结构" class="headerlink" title="wepack的插件结构"></a>wepack的插件结构</h2><h3 id="通过插件的方式组织代码"><a href="#通过插件的方式组织代码" class="headerlink" title="通过插件的方式组织代码"></a>通过插件的方式组织代码</h3><p>webpack因为其宏大的愿景，为了满足各种情况下的使用需求，必须使用一个可扩展的方式来实现。现在我们知道webpack使用了插件的体系结构来实现的。实现其插件体系结构的核心是Tapable.js这个插件引擎。但是Tapable.js只提供了基础的插件插件核心，如何使用Tapable.js实现webpack繁多复杂的功能则是另一个内容庞大的话题。</p><p>webpack中每一个继承了<code>Tapable</code>的类都是一个可通过插件扩展的节点。</p><p>比较重要的类有：</p><ul><li><code>Compiler</code>: 编译器抽象，顶层插件管理者</li><li><code>Compilation</code>：编译过程抽象</li><li><code>Resolver</code>： 路径解析过程抽象</li><li><code>Parser</code>： ast解析过程抽象</li><li><code>NormalModuleFactory</code>： 模块构建过程抽象</li><li><code>Template</code>： 编译结果输出抽象</li></ul><p>每个类所做的工作不是本文关注重点，按下不表。</p><p>webpack通过<code>webpack.config.js</code>的<code>plugins</code>配置项将插件注册入口暴露给开发者。配置在<code>plugins</code>里的插件实例通过<code>apply</code>方法获得<code>Compiler</code>实例引用。<code>Compiler</code>管理着webpack顶层的生命周期。一个生命周期对应着一个命名插件列表。获得<code>Compiler</code>实例引用的插件可以在其不同生命周期注册新的回调。回调通过参数获取其他插件节点（包括<code>Compilation</code>，<code>Resolver</code>，<code>NormalModuleFactory</code>等）的实例。回调执行时可以在新持有的插件节点实例上注册新的回调。</p><p>一个生命周期内注册的插件只能是还未执行的生命周期的插件，已执行过的生命周期上注册的新的插件不会被触发执行。</p><p>要在特定生命周期上注册插件，我们需要先获得对应节点的实例。而获得得对应节点的实例我们可能需要通过该节点实例的管理者的特定生命周期间接获取。</p><h3 id="一个典型的webpack插件生命周期"><a href="#一个典型的webpack插件生命周期" class="headerlink" title="一个典型的webpack插件生命周期"></a>一个典型的webpack插件生命周期</h3><p>下面是一个典型的webpack插件的定义（来自<a href="http://webpack.github.io/docs/how-to-write-a-plugin.html" target="_blank" rel="noopener">webpack1.x documentation - how-to-write-a-plugin</a>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorldPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Setup the plugin instance with options...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.plugin(<span class="string">'done'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloWorldPlugin;</span><br></pre></td></tr></table></figure><p>一个插件通常在<code>webpack.config.js</code>配置文件里创建实例，如下所示（改自<a href="http://webpack.github.io/docs/using-plugins.html" target="_blank" rel="noopener">webpack1.x documentation - using-plugins</a>）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        new webpack.HelloWorldPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在执行构建命令：<br></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> webpack -c webpack.config.js</span></span><br></pre></td></tr></table></figure><p></p><p>时会执行<code>compiler.apply</code>方法，这个方法遍历执行所有配置的插件实例上的<code>apply</code>方法。<code>HelloWorldPlugin</code>插件实例会在<code>compiler</code>的<code>done</code>这一生命周期注册回调。当<code>compiler</code>通过上面描述的<code>Tapable.js</code>的<code>applyXXX</code>方法发布<code>done</code>这个事件时，<code>HelloWorldPlugin</code>实例注册的<code>done</code>回调会被执行。</p><p>webpack本身就是由这种方式通过各种插件如同积木一样搭建起来，这些插件有决定<code>require</code>函数解析文件路径方式的，有决定全局变量查找方式的，有决定模块编译之后输出格式的，有决定抽取公共模块方式的…</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>在以webpack为工具链核心的工作流里，了解webpack实现是很有必要的。webpack实现时是通过插件的架构组织的代码，其插件的核心则是<code>Tapable.js</code>这个模块。<code>Tapable.js</code>本质上又一个发布-订阅模式的变体。上文先解释了一个简单的发布订阅模式的实现，然后通过代码描述了<code>Tapable.js</code>的API功能，最后通过一个简单的插件的例子描述了一个webpack插件的生命周期——定义，实例化和执行。</p><p>一些微小的工作，希望对大家有所帮助。</p><hr><h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ul><li><a href="https://github.com/webpack/webpack/tree/webpack-1" target="_blank" rel="noopener">webpack源码</a></li><li><a href="http://webpack.github.io/docs/" target="_blank" rel="noopener">webpack 1.x Documentation</a></li><li><a href="https://github.com/webpack/tapable/tree/v0.1.9" target="_blank" rel="noopener">Tapable.js源码</a></li></ul></div><footer class="article-footer"><a data-url="https://f-12.github.io/Hexo/2017/09/25/webpack的插件体系结构/" data-id="cjvj9vo8h0026qex0h327mc5s" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/javascript/">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/webpack/">webpack</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/插件体系/">插件体系</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/源码分析/">源码分析</a></li></ul></footer></div></article><article id="post-知其所以然-Binding-System-of-Vue" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/" class="article-date"><time datetime="2016-09-19T14:42:00.000Z" itemprop="datePublished">2016-09-19</time></a></div><div class="article-inner"><header class="article-header"><h1 itemprop="name"><a class="article-title" href="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/">知其所以然-Binding_System_of_Vue</a></h1></header><div class="article-entry" itemprop="articleBody"><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li style="list-style:none"><input type="checkbox" checked> 理解Vue如何根据data生成DOM及挂载到Document对象上</li><li style="list-style:none"><input type="checkbox" checked> 理解Vue如何实现更新data属性值时自动更新DOM</li><li style="list-style:none"><input type="checkbox" checked> 理解Vue如何实现v-*指令</li></ul><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="DOM更新"><a href="#DOM更新" class="headerlink" title="DOM更新"></a>DOM更新</h2><p>浏览器构建DOM Tree，渲染视图，并提供DOM API更新视图。浏览器保证视图的渲染结果和DOM Tree中的数据同步。开发者经常会从服务器加载数据更新到视图上，或根据用户的交互改变视图。这些改变视图的方式可以抽象成改变视图状态数据（即数据驱动视图）。</p><p>我们一般都会使用data object保存从服务器加载到的数据或记录用户交互的状态数据，然后把这些data object里的数据同步到DOM对象的各个属性值上，触发视图的更新。</p><p>一般的做法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  Hello,&lt;span id=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var name = &apos;f-12&apos;;</span><br><span class="line">  $(&apos;#name&apos;).text(name);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>name代表data object（既可能是从服务器上加载的数据，也可能是用户交互产生的状态数据），当我们把值赋给DOM的属性（使用原生DOM API或jQuery)，修改视图后，data，object就和DOM的属性值没有关系了，假如我们再次更新name，DOM属性值并不会变化，因而视图也不会变化。我们必须再次修改DOM属性才可以更新视图，即每次状态数据发生变动时我们必须手动更新视图。</p><p>手动更新DOM显得很繁琐。前端工程更加复杂，用户交互更加复杂，单页应用更加流行，产生了更多的状态数据，这些因素也凸显了手动更新DOM的缺点。</p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><p>Data Binding的思想就是建立data object和DOM对象之前的关系，使得我们修改data object上的属性值时自动完成DOM对象的更新。要完成这个特性，我们很自然想到了观察者模式（发布/订阅模式）</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul><li><strong>定义</strong></li></ul><blockquote><p>The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically.</p></blockquote><ul><li><p><strong>原理</strong></p><img src="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/js_observer_pattern.png"></li><li><p><strong>Pull vs Push</strong><br>javascript有两种observer pattern的实现方式：pull和push。</p><ul><li>Push： observable状态更新时使用变更的数据作为参数调用observer注册的回调</li><li>Pull： observable状态变更时简单通知observer更新，observer使用自身持有的observable引用获取感兴趣的状态。</li></ul><p>( Vue中使用的Pull方式实现的observer pattern )</p></li><li><p><strong>用到Observer的地方</strong></p><ul><li>jQuery对象的on/trigger方法</li><li>Node里EventEmitter的on/emmit方法</li><li>DOM里EventTarget的onXXX</li></ul></li></ul><h1 id="Vue的Data-Binding"><a href="#Vue的Data-Binding" class="headerlink" title="Vue的Data Binding"></a>Vue的Data Binding</h1><img src="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/vue_binding_model.png"><blockquote><p>Reference: vuejs.org</p></blockquote><p>Web开发中比较频繁出现的场景是：</p><ul><li>有很多状态数据需要同步到DOM上（DOM操作，jQuery流行的主要因素）</li><li>多个DOM对象用到同一个状态数据，状态发生变动时需要更新所有DOM(Data Binding，MVVM流行的推动力)</li></ul><p>本次我们主要关注Vue的Data Binding实现的方式。</p><p>继续进行前，我们需要引入一个最简单的🌰。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  This is a &#123;&#123; message &#125;&#125;.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue.js!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Reference: <a href="http://vuejs.org/guide/" target="_blank" rel="noopener">vuejs.org</a></p></blockquote><p>这个代码段的效果是页面渲染时，message的值会自动同步到DOM中，当修改message时，DOM会同步更新。<br>接下来，我们来探究一下这一切是怎么发生的。</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p><code>new Vue()</code>之前，我们首先得引入Vue的库，我们使用ES6的<code>import</code>方式。<br><code>import Vue from &#39;vue&#39;</code>执行时，会首先找到<code>vue</code>包，然后执行里面的<code>index.js</code>代码，将其中导出的对象绑定到<code>Vue</code>这个标识符上。这一行代码完成Vue类的定义，导出一个构造函数来供使用者实例化。</p><p><code>import</code>过程体现了<code>Vue</code>的扩展能力，提现了<code>Vue</code>支持自定义<code>directive</code>，<code>filter</code>，<code>watch</code>等特性的方式。但是这个不是我们这次的关注重点，略过不讲。<br>有了Vue的构造函数，就可以用它进行实例化了。Vue实例化时做了很多事情，支撑起了Vue的<code>运行时</code>。</p><p><strong>debate</strong> <code>Vue</code>是库(<code>lib</code>)还是框架(<code>framework</code>) ?</p><h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><h3 id="el选项"><a href="#el选项" class="headerlink" title="el选项"></a><code>el</code>选项</h3><p>以下段落来自Vuejs官方文档对<code>el</code>选项的描述。</p><ul><li><p><strong>Type:</strong> <code>string | HTMLElement</code></p></li><li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p></li><li><p><strong>Details:</strong></p><p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p><p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p><p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p><p class="tip">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p></li><li><p><strong>See also:</strong> <a href="/guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p></li></ul><p><code>el</code>选项提供<code>Vue</code>实例对象的挂载点，最终<code>Vue</code>实例将编译出一个<code>DOM</code>对象替换<code>el</code>对象的<code>DOM</code>。</p><p><code>el</code>的值可以是一个选择器<code>String</code>也可以是一个DOM <code>HTMLElement</code>元素，这样提供我们动态挂载Vue实例对象的能力，可以先<code>new Vue()</code>时不提供<code>el</code>值，得到<code>vm</code>对象后动态决定挂载点，调用<code>vm.$mount()</code>进行手动挂载。</p><h3 id="data选项"><a href="#data选项" class="headerlink" title="data选项"></a><code>data</code>选项</h3><p>以下段落来自Vuejs官方文档对<code>data</code>选项的描述。</p><ul><li><p><strong>Type:</strong> <code>Object | Function</code></p></li><li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p></li><li><p><strong>Details:</strong></p><p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.</p></li></ul><p><code>data</code>选项的值可以是<code>Object</code>，一般在根实例中这样定义；可以是<code>Function</code>，组件中必须是<code>Function</code>。原因是javascript的对象是可变对象，这样做可以避免多个组件实例公用同样的对象引用。</p><p>实例化过程中会执行<code>_initData()</code>，在这个过程的最后一步是<code>observe</code>过程，将<code>data</code>选项转化为响应式数据。转化结果是<code>data</code>对象的<code>__ob__</code>保存新建的<code>Observer</code>对象，且此<code>__ob__.value</code>属性保存<code>data</code>选项对象。同时会遍历<code>data</code>选项对象的每个键值，使用ES6的<code>Object.defineProperty</code>定义其Getter和Setter。如果键值也是对象，会递归调用<code>observe</code>函数，即<code>observe(key)</code>。<br>完成<code>observe</code>调用后的<code>this.$data</code>结构<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __ob__: &#123;</span><br><span class="line">    dep: &#123;</span><br><span class="line">      subs: []</span><br><span class="line">    &#125;</span><br><span class="line">    value: &#123;&#125; <span class="comment">//即this.$data自身</span></span><br><span class="line">    vms: [] <span class="comment">//所有持有此data对象的vm实例</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> message() &#123;&#125;</span><br><span class="line">  <span class="keyword">set</span> message(newVal) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为<code>observe</code>过程是在<code>_initData()</code>过程中发生，而这个过程又在<code>new Vue(options)</code>构造函数的执行中进行，所以一旦实例创建结束后，再往<code>data</code>上增加的新键值并不是响应式，因为没有经过<code>observe</code>过程转化为响应式属性。Vue解决这种场景的方式是提供了<code>Vue.$set</code>方法。</p><h3 id="Text-Node中的mustache编译"><a href="#Text-Node中的mustache编译" class="headerlink" title="Text Node中的mustache编译"></a>Text Node中的<code>mustache</code>编译</h3><h4 id="提取表达式"><a href="#提取表达式" class="headerlink" title="提取表达式"></a>提取表达式</h4><ul><li><strong>NodeType识别Text Node</strong></li><li><strong>正则表达式提取expression</strong><br>safe: <code>\{\{((?:.|\\n)+?)\}\}</code><br>unsafe: <code>\{\{\{((?:.|\\n)+?)\}\}\}</code></li><li><p><strong>创建包装getter</strong><br>创建包装的getter函数时使用<code>new Function(string)</code>完成，string是上一步提取的<code>表达式</code>的值。包装过程中一个<code>scope</code>的概念，指的是当前组件上下文，对于root组件来说是<code>undefined</code>。这也是访问没有定义的变量时console里经常报错<code>scope.xxx</code>找不到等错误的原因。</p><p>上面例子中的 <code>This is a .</code>提取后形成下面的<code>tokens</code>列表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">value</span>: <span class="string">'this is a '</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    html: <span class="literal">false</span>,        <span class="comment">// 是否由unsafe模式匹配到的</span></span><br><span class="line">    oneTime: <span class="literal">false</span>,     <span class="comment">// 稍后介绍</span></span><br><span class="line">    tag: <span class="literal">true</span>,          <span class="comment">// 是否由safe或unsafe模式匹配到的</span></span><br><span class="line">    value: <span class="string">'message'</span>    <span class="comment">// 匹配到的文本值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="attr">value</span>: <span class="string">'.'</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Text中的每一个<code>mustache</code>匹配到的文本将生成类似列表中第二个对象的一个token对象。其他token是由其余简单文本生成的。</p></li></ul><h4 id="创建Text-Node"><a href="#创建Text-Node" class="headerlink" title="创建Text Node"></a>创建Text Node</h4><p>根据每个<code>tag</code>属性为true的token使用<code>function processTextToken (token, options) {}</code>处理，创建对应的Text Node对象并加入到一个新创建的<code>DocumentFragment</code>对象中。此过程中将进一步对token标记<code>descriptor</code>。<code>mustache</code>内部可能包含的过滤器调用也是在<code>descriptor</code>中标记。<code>token.tag</code>为<code>false</code>直接生成简单的Text Node。<br>此时的token结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  html: <span class="literal">false</span>,</span><br><span class="line">  oneTime: <span class="literal">false</span>,</span><br><span class="line">  tag: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">'message'</span>,</span><br><span class="line">  descriptor: &#123;</span><br><span class="line">    name: <span class="string">'text'</span>,           <span class="comment">// 表示当前token代表一个text node</span></span><br><span class="line">    <span class="comment">// directives/public/text预先定义的directive</span></span><br><span class="line">    def: &#123;</span><br><span class="line">      bind() &#123;&#125;,</span><br><span class="line">      update() &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    expression: <span class="string">'message'</span>,  <span class="comment">// 由token中的值生成的表达式</span></span><br><span class="line">    filters: <span class="literal">undefined</span>      <span class="comment">// 可能包含的过滤器调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>递归编译每个DOM节点时，会对每个node生成对应的linker函数，这些linker会最终组合成一个linker。编译过程结束后，调用这个函数会开始link过程。代码概括为<code>compile(el, options)(this, el)</code>。link过程会递归调用所有的linker。</p><p>每个linker调用会创建一个<code>Directive</code>对象并添加到Vue实例的<code>_directives</code>数组中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this._directives.push(</span><br><span class="line">  new Directive(</span><br><span class="line">    descriptor, // 编译过程中token中标记的discriptor</span><br><span class="line">    this,       // 当前Vue实例</span><br><span class="line">    node,       // 创建的对应DOM node对象</span><br><span class="line">    host,       // 宿主DOM node</span><br><span class="line">    scope,</span><br><span class="line">    frag</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>当所有的<code>Directive</code>对象添加到Vue实例的<code>_directives</code>数组中后，会遍历新增加的所有<code>Directive</code>，调用其上的<code>_bind</code>方法。（由于Vue提供了通过自定义<code>Directive</code>复用代码的方式，这里为了防止在实例化过程中调用到这些<code>Directive</code>的<code>_bind</code>方法，Vue通个<code>Directive.discriptor.priority</code>中保存自身优先级， link过程中创建的<code>Directive</code>对象都具有默认优先级。然后遍历前会现根据优先级排序。）</p><p>如下代码所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalDirCount = vm._directives.length</span><br><span class="line">linker()</span><br><span class="line"><span class="keyword">var</span> dirs = vm._directives.slice(originalDirCount)</span><br><span class="line">sortDirectives(dirs)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = dirs.length; i &lt; l; i++) &#123;</span><br><span class="line">  dirs[i]._bind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至此link过程完成了一半，继续进行下一半前，我们需要引入<code>Directive</code>类和<code>Watcher</code>类。</p><p>一个directive对象将DOM Element和data中的属性链接起来，并在内部注册一个Watchre对象，在data属性更新时调用update函数更新DOM对象。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  vm: <span class="built_in">Object</span>,           <span class="comment">// Vue实例</span></span><br><span class="line">  el: <span class="built_in">Object</span>,           <span class="comment">// 根DOM</span></span><br><span class="line">  descriptor: <span class="built_in">Object</span>,   <span class="comment">// discriptor</span></span><br><span class="line">  name: <span class="built_in">String</span>,         <span class="comment">// discriptor.name</span></span><br><span class="line">  expression: <span class="built_in">Object</span>,   <span class="comment">// discriptor.expression</span></span><br><span class="line">  arg: <span class="built_in">Object</span>,          <span class="comment">// discriptor.arg</span></span><br><span class="line">  modifiers: [],    <span class="comment">// discriptor.modifiers</span></span><br><span class="line">  filters: [],      <span class="comment">// discriptor.filters</span></span><br><span class="line">  literal: ,</span><br><span class="line">  _locked: <span class="built_in">Boolean</span>, <span class="comment">//</span></span><br><span class="line">  _bound: <span class="built_in">Boolean</span>,   <span class="comment">// intial bind后为true</span></span><br><span class="line">  _listeners: [], <span class="comment">//</span></span><br><span class="line">  _host: <span class="built_in">Object</span>,        <span class="comment">// context信息</span></span><br><span class="line">  _scope: <span class="built_in">Object</span>,     <span class="comment">// context信息</span></span><br><span class="line">  _frag: <span class="built_in">Object</span>     <span class="comment">// context信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Directive</span> (<span class="params">descriptor, vm, el, host, scope, frag</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Directive.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 其他一些方法 */</span></span><br></pre></td></tr></table></figure><p></p><p>一个Watcher对象封装一个表达式，收集该表达式的依赖项，在表达式的值发生变化时调用回调函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 内部数据结构如下</span><br><span class="line">&#123;</span><br><span class="line">  vm： Vue, // Vue实例</span><br><span class="line">  expression: String | Function,   // 被封装的表达式，来自discriptor.expression</span><br><span class="line">  cb: Function,</span><br><span class="line">  id: Number,                      // 内部自增全局变量uid，批处理使用</span><br><span class="line">  active: Boolean,</span><br><span class="line">  dirty: Boolean,                  // lazy watchers标志量</span><br><span class="line">  deps: [],                        //</span><br><span class="line">  newDeps: [],</span><br><span class="line">  depIds: Set,</span><br><span class="line">  newDepIds: Set,</span><br><span class="line">  prevError: null, // for async error stacks</span><br><span class="line">  getter: Function,</span><br><span class="line">  setter: Function,</span><br><span class="line">  queued: Boolean, // for avoiding false triggers for deep and Array</span><br><span class="line">  shallow: Boolean // for avoiding false triggers for deep and Array</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">export default function Watcher (vm, expOrFn, cb, options) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.get = function() &#123;&#125;           // 计算expression的值并重新计算依赖</span><br><span class="line">Watcher.prototype.set = function(value) &#123;&#125;      // 先应用可能的filter然后设置对应属性值</span><br><span class="line">Watcher.prototype.beforeGet = function() &#123;&#125;     // 设置全局Dep.target为当前Watcher实例，准备收集依赖</span><br><span class="line">Watcher.prototype.afterGet = function() &#123;&#125;      //</span><br><span class="line">Watcher.prototype.update = function(shallow) &#123;&#125; // Subscriber接口，被Publisher调用，Vue的Publisher由Dep实现</span><br><span class="line">Watcher.prototype.run = function() &#123;&#125;           // Batch job接口，被batcher调用</span><br><span class="line">Watcher.prototype.evalute = function() &#123;&#125;</span><br><span class="line">Watcher.prototype.addDep = function() &#123;&#125;        //</span><br><span class="line">Watcher.prototype.depend = function() &#123;&#125;        // 遍历调用deps上的depend</span><br><span class="line">Watcher.prototype.teardown = function() &#123;&#125;      // 清楚一个watcher，遍历调用deps里的removeSub()移除对其的订阅</span><br></pre></td></tr></table></figure><p></p><p>在directive对象bind的过程中， 会删除<code>el</code> DOM上声明的v-*指令，然后将discriptor上定义的属性mixin到自身，并调用<code>discriptor.bind()</code>完成initial bind。<br>然后会new一个Watcher对象，并初始化更新DOM，将data上的初始化值更新到DOM上（这里需要例外处理v-model，将input的inline value回写到data中）。</p><p>此时我们生成的<code>Directive</code>和<code>Watcher</code>对象如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    _bound: true,</span><br><span class="line">    _frag: undefined,</span><br><span class="line">    _host: undefined,</span><br><span class="line">    _listeners: null,</span><br><span class="line">    _locked: false,</span><br><span class="line">    _scope: undefined,</span><br><span class="line">    _update() &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    _watcher: &#123;                   // 每个directive对象都会持有一个watcher对象</span><br><span class="line">        id: 1,</span><br><span class="line">        active: true,</span><br><span class="line">        cb(val, oldVal) &#123;&#125;,</span><br><span class="line">        deep: undefined,</span><br><span class="line">        depIds: [1],</span><br><span class="line">        deps: [Watcher],</span><br><span class="line">        dirty: undefined,</span><br><span class="line">        expression: &quot;message&quot;,</span><br><span class="line">        filters: undefined,</span><br><span class="line">        getter() &#123;&#125;</span><br><span class="line">        newDepIds: [],</span><br><span class="line">        newDeps: [],</span><br><span class="line">        postProcess: null,</span><br><span class="line">        preProcess: null,</span><br><span class="line">        prevError: null,</span><br><span class="line">        queued: false,</span><br><span class="line">        scope: undefined,</span><br><span class="line">        setter: undefined,</span><br><span class="line">        shallow: false,</span><br><span class="line">        twoWay: undefined,</span><br><span class="line">        value: &quot;hello world&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    arg: undefined,</span><br><span class="line">    attr: &quot;data&quot;,               // 因为是data选项中定义的属性，所以值为data，如果只是简单text则为textContent</span><br><span class="line">    descriptor: Object,         // token.descriptor</span><br><span class="line">    bind: bind(),               // token.descriptor.bind</span><br><span class="line">    update(value) &#123;&#125;,           // token.descriptor.update</span><br><span class="line">    el: Text,                   // DOM中的Text类实例</span><br><span class="line">    expression: &quot;message&quot;,</span><br><span class="line">    filters: undefined,</span><br><span class="line">    literal: undefined,</span><br><span class="line">    modifiers: undefined,</span><br><span class="line">    name: &quot;text&quot;,               // 标明此directive对象注册时key为text，自定义directive时将由Vue.directive(name, Object)提供name</span><br><span class="line">    vm : Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="依赖系统"><a href="#依赖系统" class="headerlink" title="依赖系统"></a>依赖系统</h4><p>前面讲解link过程时，提到了收集依赖。所以一并讲解下Vue的依赖系统。依赖系统本质上是一个发布-订阅模式的实现。<code>Watcher</code>实现订阅者职责，<code>Dep</code>实现发布者职责，发布的内容是自身值的改变，<code>Watcher</code>对应的响应是使用依赖重新计算自己的值并调用回调函数。</p><p>为此引入<code>Dep</code>类。<br>一个Dep对象是一个发布者，可以被多个directive（实际上是directive里面的watcher）订阅。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部结构</span></span><br><span class="line">&#123;</span><br><span class="line">  id: <span class="built_in">Number</span>,      <span class="comment">// 自增的uid</span></span><br><span class="line">  subs: []         <span class="comment">// 实现了update方法的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dep.target        <span class="comment">// 全局变量，标志当前收集依赖的Watcher对象</span></span><br><span class="line"></span><br><span class="line">Dep.prototyp.addSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 增加订阅者</span></span><br><span class="line">Dep.prototyp.removeSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 移除订阅者</span></span><br><span class="line">Dep.prototyp.depend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 将自身增加当Dep.target的依赖中</span></span><br><span class="line">Dep.prototyp.notify   = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 遍历调用subs里对象的update方法，即发布更新</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Binding流程"><a href="#Binding流程" class="headerlink" title="Binding流程"></a>Binding流程</h4><p>下面使用流程图总结一下这个过程中的行为。<br><img src="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/vue_binding_sequence.png"></p><p><strong>Workshop</strong> debug <code>vm.message = &#39;Goodbye World&#39;</code>时的执行时序</p><h1 id="指令处理"><a href="#指令处理" class="headerlink" title="指令处理"></a>指令处理</h1><p><code>Vue</code>会根据写在<code>template</code>里的模板编译出<code>DOM</code>对象。<code>template</code>模板本身是<code>html</code>代码，<code>Vue</code>的功能通过写在html代码里的指令，<code>mustache</code>代码以及自定义<code>tag</code>实现。<br>模板的编译本质上是手动创建<code>DOM</code>树的过程。Vue中指令主要有<code>v-*</code>指令以及<code></code>指令，还有<code>number</code>, <code>transition</code>, <code>keep-alive</code>等属性指令，还有<code>&lt;component&gt;&lt;/component&gt;</code>等元素指令，还有自定义组件标签指令。</p><h2 id="Terminal指令"><a href="#Terminal指令" class="headerlink" title="Terminal指令"></a>Terminal指令</h2><h3 id="v-if指令"><a href="#v-if指令" class="headerlink" title="v-if指令"></a><code>v-if</code>指令</h3><h4 id="v-if-compile"><a href="#v-if-compile" class="headerlink" title="v-if compile"></a><code>v-if</code> <strong>compile</strong></h4><p>开始前，我们需要小小修改下实例代码，如下。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span>,</span><br><span class="line">    message: <span class="string">'Hello Vue.js!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结合之前讲的过程，直接从compile阶段开始。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileElement</span>(<span class="params">el, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// preprocess textareas.</span></span><br><span class="line">  <span class="comment">// textarea treats its text content as the initial value.</span></span><br><span class="line">  <span class="comment">// just bind it as an attr directive for value.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> linkFn;</span><br><span class="line">  <span class="keyword">var</span> hasAttrs = el.hasAttributes();</span><br><span class="line">  <span class="keyword">var</span> attrs = hasAttrs &amp;&amp; toArray(el.attributes);</span><br><span class="line">  <span class="comment">// check terminal directives (for &amp; if)</span></span><br><span class="line">  <span class="keyword">if</span> (hasAttrs) &#123;</span><br><span class="line">    linkFn = checkTerminalDirectives(el, attrs, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check element directives</span></span><br><span class="line">  <span class="keyword">if</span> (!linkFn) &#123;</span><br><span class="line">    linkFn = checkElementDirectives(el, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check component</span></span><br><span class="line">  <span class="keyword">if</span> (!linkFn) &#123;</span><br><span class="line">    linkFn = checkComponent(el, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// normal directives</span></span><br><span class="line">  <span class="keyword">if</span> (!linkFn &amp;&amp; hasAttrs) &#123;</span><br><span class="line">    linkFn = compileDirectives(attrs, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> linkFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码会从<code>el</code>选项指示的挂载点<code>div#app</code>开始，可以断定，在实例代码中，会执行两次，第一次针对<code>div#app</code>, 第二次针对<code>span</code>。跳过对<code>div#app</code>的编译过程，直接看对<code>span</code>执行的过程。<br>代码标明对指令的处理主要经过了两个过程：check和compile。其中check会分别检查<strong>terminal directive</strong>，<strong>element directive</strong>， <strong>component</strong>。其中<strong>terminal directive</strong>指的是<code>v-*</code>指令，<strong>element directive</strong>指类似<code>&lt;component&gt;&lt;/component&gt;</code>这样的自定义标签指令，<strong>component</strong>指令指自Vue组件。<br>实例代码比较简单所以只会执行<code>checkTerminalDirectives</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTerminalDirectives</span>(<span class="params">el, attrs, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// skip v-pre</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// skip v-else block, but only if following v-if</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = attrs.length; i &lt; j; i++) &#123;</span><br><span class="line">    attr = attrs[i];</span><br><span class="line">    name = attr.name.replace(modifierRE, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (matched = name.match(dirAttrRE)) &#123;</span><br><span class="line">      def = resolveAsset(options, <span class="string">'directives'</span>, matched[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (def &amp;&amp; def.terminal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) &gt; termDef.priority) &#123;</span><br><span class="line">          termDef = def;</span><br><span class="line">          rawName = attr.name;</span><br><span class="line">          modifiers = parseModifiers(attr.name);</span><br><span class="line">          value = attr.value;</span><br><span class="line">          dirName = matched[<span class="number">1</span>];</span><br><span class="line">          arg = matched[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (termDef) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程会遍历element attribute node列表，<code>name.match(dirAttrRE)</code>来匹配到需要处理的<code>v-*</code>指令。这里<code>dirAttrRE</code>是正则表达式：<code>/^v-([^:]+)(?:$|:(.*)$)/</code>。<br>对每个特定的terminal directive，<code>def = resolveAsset(options, &#39;directives&#39;, matched[1])</code>获取内置的指令<code>def</code>对象, 实例中即为<code>def = resolveAsset(options, &#39;directives&#39;, &#39;if&#39;)</code>。Terminal directive 的<code>def</code>对象在’src/directives/public/‘目录下定义，每个<code>def</code>对象定义了<code>bind</code>过程中调用的接口方法, 如下所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  priority: DEFAULT_TERMINAL_PRIORITY,</span><br><span class="line">  terminal: <span class="literal">true</span>,</span><br><span class="line">  bind() &#123;&#125;,</span><br><span class="line">  update(value) &#123;&#125;,</span><br><span class="line">  insert() &#123;&#125;,</span><br><span class="line">  remove() &#123;&#125;,</span><br><span class="line">  updateRef() &#123;&#125;,</span><br><span class="line">  unbind() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个<code>def</code>对象，讲解<code>Text Node</code>编译过程中也涉及到了，当时只有<code>bind</code>和<code>update</code>方法。</p><h4 id="v-if-link"><a href="#v-if-link" class="headerlink" title="v-if link"></a><code>v-if</code> link</h4><p>编译完成后，将进行<code>link</code>过程。此过程和Text Node的link过程基本一致，最终会执行如下代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._directives.push(</span><br><span class="line">  <span class="keyword">new</span> Directive(</span><br><span class="line">    descriptor, <span class="comment">// 编译过程中token中标记的discriptor</span></span><br><span class="line">    <span class="keyword">this</span>,       <span class="comment">// 当前Vue实例</span></span><br><span class="line">    node,       <span class="comment">// 创建的对应DOM node对象</span></span><br><span class="line">    host,       <span class="comment">// 宿主DOM node</span></span><br><span class="line">    scope,</span><br><span class="line">    frag</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// descriptor:</span></span><br><span class="line">&#123;</span><br><span class="line">  arg: <span class="literal">undefined</span>,</span><br><span class="line">  attr: <span class="string">'v-if'</span>,</span><br><span class="line">  def: &#123;&#125;,              <span class="comment">// 上文有详述，略去细节</span></span><br><span class="line">  expression: <span class="string">'show'</span>,</span><br><span class="line">  filters: <span class="literal">undefined</span>,</span><br><span class="line">  modifiers: &#123;&#125;         <span class="comment">// 空对象</span></span><br><span class="line">  name: <span class="string">'if'</span>,</span><br><span class="line">  raw: <span class="string">'show'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node: &lt;span v-if="show"&gt; &#123;&#123; show &#125;&#125;&lt;/span&gt;</span></span><br></pre></td></tr></table></figure><p></p><h4 id="v-if-bind"><a href="#v-if-bind" class="headerlink" title="v-if bind"></a><code>v-if</code> <strong>bind</strong></h4><p>上面<strong>link</strong>过程结束后，会开始<strong>bind</strong>过程，具体请见上一节。<code>v-if</code>的<strong>bind</strong>过程中多态部分是执行<code>v-if def</code>对象上的<code>bind() {}</code>的过程。如下代码所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="keyword">this</span>.el;</span><br><span class="line">    <span class="keyword">if</span> (!el.__vue__) &#123;</span><br><span class="line">      <span class="comment">// check else block</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// check main block</span></span><br><span class="line">      <span class="keyword">this</span>.anchor = createAnchor(<span class="string">'v-if'</span>);</span><br><span class="line">      replace(el, <span class="keyword">this</span>.anchor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// debug info</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个过程其实就是简单的创建了一个空白的Text Node替换了<code>&lt;span&gt;&lt;/span&gt;</code>DOM元素，所以页面中开始出现<code></code>会出现短暂地变成空白。但是<code>createAnchor</code>的设计意图可以深究一下，目前所知就是为了和后面的<strong>初始化update</strong>结合使用，<code>update</code>环节会获取<code>show</code>的值，根据值计算节点, 调用<code>def.insert</code>方法，将正式DOM插入到<code>createAnchor</code>所在位置。</p><p><strong>bind</strong>的其他过程同上节所示。</p><h3 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a><code>v-for</code>指令</h3><p><code>v-for</code>指令的<strong>compile</strong>和<strong>link</strong>过程和<code>v-if</code>指令大致相同，区别仅在<strong>bind</strong>过程调用<code>def.bind</code>和<code>def.update</code>上。<br>但是<code>v--for</code>指令有性能优化的问题要解决，比如列表更新时如何最少化DOM操作，如何进行实例缓存等。<br>Vue使用<code>diff</code>算法解决列表渲染中列表动态变化的问题。</p><h3 id="其他v-指令"><a href="#其他v-指令" class="headerlink" title="其他v-*指令"></a>其他<code>v-*</code>指令</h3><p>类似的处理，但是涉及不同情况的细节处理。可以细看<code>src/directive/public/</code>目录下的代码。</p><h2 id="Element指令"><a href="#Element指令" class="headerlink" title="Element指令"></a><code>Element</code>指令</h2><h3 id="lt-component-gt-lt-component-gt-指令"><a href="#lt-component-gt-lt-component-gt-指令" class="headerlink" title="&lt;component&gt;&lt;/component&gt;指令"></a><code>&lt;component&gt;&lt;/component&gt;</code>指令</h3><h3 id="lt-slot-gt-lt-slot-gt-指令"><a href="#lt-slot-gt-lt-slot-gt-指令" class="headerlink" title="&lt;slot&gt;&lt;/slot&gt;指令"></a><code>&lt;slot&gt;&lt;/slot&gt;</code>指令</h3><p>这个也很简单，处理node attribute时检查slot属性，然后替换父节点内的name匹配的slot节<br>点即可。</p><h2 id="Custom-Component指令"><a href="#Custom-Component指令" class="headerlink" title="Custom Component指令"></a><code>Custom Component</code>指令</h2><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://github.com/banama/aboutVue" target="_blank" rel="noopener">banama/abountVue</a></li><li><a href="http://jiongks.name/blog/vue-code-review/" target="_blank" rel="noopener">jinks</a></li></ul></div><footer class="article-footer"><a data-url="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/" data-id="cjvj9vo8i0027qex0u6gk8jg5" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Vue/">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Web/">Web</a></li></ul></footer></div></article><nav id="page-nav"><a class="extend prev" rel="prev" href="/Hexo/">&laquo; __('prev')</a><a class="page-number" href="/Hexo/">1</a><span class="page-number current">2</span></nav></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Tags</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/ALert/">ALert</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Lock/">Lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Monitoring/">Monitoring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Prometheus/">Prometheus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/SpringBootAdmin/">SpringBootAdmin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/fork/">fork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/join/">join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/告警/">告警</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/插件体系/">插件体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/监控/">监控</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/线程池/">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/锁/">锁</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/Hexo/tags/ALert/" style="font-size:10px">ALert</a> <a href="/Hexo/tags/Java/" style="font-size:17.5px">Java</a> <a href="/Hexo/tags/Javascript/" style="font-size:10px">Javascript</a> <a href="/Hexo/tags/Lock/" style="font-size:10px">Lock</a> <a href="/Hexo/tags/Monitoring/" style="font-size:17.5px">Monitoring</a> <a href="/Hexo/tags/Prometheus/" style="font-size:12.5px">Prometheus</a> <a href="/Hexo/tags/RabbitMQ/" style="font-size:10px">RabbitMQ</a> <a href="/Hexo/tags/Spring/" style="font-size:10px">Spring</a> <a href="/Hexo/tags/SpringBootAdmin/" style="font-size:10px">SpringBootAdmin</a> <a href="/Hexo/tags/Vue/" style="font-size:10px">Vue</a> <a href="/Hexo/tags/Web/" style="font-size:10px">Web</a> <a href="/Hexo/tags/fork/" style="font-size:10px">fork</a> <a href="/Hexo/tags/javascript/" style="font-size:10px">javascript</a> <a href="/Hexo/tags/join/" style="font-size:10px">join</a> <a href="/Hexo/tags/webpack/" style="font-size:10px">webpack</a> <a href="/Hexo/tags/告警/" style="font-size:10px">告警</a> <a href="/Hexo/tags/并发/" style="font-size:12.5px">并发</a> <a href="/Hexo/tags/微服务/" style="font-size:20px">微服务</a> <a href="/Hexo/tags/插件体系/" style="font-size:10px">插件体系</a> <a href="/Hexo/tags/源码分析/" style="font-size:10px">源码分析</a> <a href="/Hexo/tags/监控/" style="font-size:15px">监控</a> <a href="/Hexo/tags/线程/" style="font-size:17.5px">线程</a> <a href="/Hexo/tags/线程池/" style="font-size:10px">线程池</a> <a href="/Hexo/tags/锁/" style="font-size:10px">锁</a></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2016/09/">September 2016</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/Hexo/2019/05/11/砖瓦集——Java并发编程演变史/">砖瓦集——Java并发编程演变史</a></li><li><a href="/Hexo/2019/05/11/砖瓦集——Java-Fork-Join/">砖瓦集——Java Fork/Join</a></li><li><a href="/Hexo/2019/05/11/砖瓦集——Java-Lock/">砖瓦集——Java Lock</a></li><li><a href="/Hexo/2019/05/10/砖瓦集——Java-Thread-Pool/">砖瓦集——Java Thread Pool</a></li><li><a href="/Hexo/2019/05/10/砖瓦集——Java-Thread/">砖瓦集——Java Thread</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2019 F-12<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></div></div></footer></div><nav id="mobile-nav"><a href="/Hexo/" class="mobile-nav-link">Home</a> <a href="/Hexo/archives" class="mobile-nav-link">Archives</a></nav><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/Hexo/fancybox/jquery.fancybox.css"><script src="/Hexo/fancybox/jquery.fancybox.pack.js"></script><script src="/Hexo/js/script.js"></script></div></body>