<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>知其所以然-Binding_System_of_Vue | 十二进制</title><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="目标 理解Vue如何根据data生成DOM及挂载到Document对象上 理解Vue如何实现更新data属性值时自动更新DOM 理解Vue如何实现v-*指令引入DOM更新浏览器构建DOM Tree，渲染视图，并提供DOM API更新视图。浏览器保证视图的渲染结果和DOM Tree中的数据同步。开发者经常会从服务器加载数据更新到视图上，或根据用户的交互改变视图。这些改变视图的方式可以抽象成改变视图状"><meta name="keywords" content="Vue,Javascript,Web"><meta property="og:type" content="article"><meta property="og:title" content="知其所以然-Binding_System_of_Vue"><meta property="og:url" content="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/index.html"><meta property="og:site_name" content="十二进制"><meta property="og:description" content="目标 理解Vue如何根据data生成DOM及挂载到Document对象上 理解Vue如何实现更新data属性值时自动更新DOM 理解Vue如何实现v-*指令引入DOM更新浏览器构建DOM Tree，渲染视图，并提供DOM API更新视图。浏览器保证视图的渲染结果和DOM Tree中的数据同步。开发者经常会从服务器加载数据更新到视图上，或根据用户的交互改变视图。这些改变视图的方式可以抽象成改变视图状"><meta property="og:locale" content="default"><meta property="og:image" content="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/js_observer_pattern.png"><meta property="og:image" content="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/vue_binding_model.png"><meta property="og:image" content="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/vue_binding_sequence.png"><meta property="og:updated_time" content="2019-04-20T10:37:04.224Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="知其所以然-Binding_System_of_Vue"><meta name="twitter:description" content="目标 理解Vue如何根据data生成DOM及挂载到Document对象上 理解Vue如何实现更新data属性值时自动更新DOM 理解Vue如何实现v-*指令引入DOM更新浏览器构建DOM Tree，渲染视图，并提供DOM API更新视图。浏览器保证视图的渲染结果和DOM Tree中的数据同步。开发者经常会从服务器加载数据更新到视图上，或根据用户的交互改变视图。这些改变视图的方式可以抽象成改变视图状"><meta name="twitter:image" content="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/js_observer_pattern.png"><link rel="alternate" href="/atom.xml" title="十二进制" type="application/atom+xml"><link rel="icon" href="/favicon.png"><link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"><link rel="stylesheet" href="/Hexo/css/style.css"></head></html><body><div id="container"><div id="wrap"><header id="header"><div id="banner"></div><div id="header-outer" class="outer"><div id="header-title" class="inner"><h1 id="logo-wrap"><a href="/Hexo/" id="logo">十二进制</a></h1></div><div id="header-inner" class="inner"><nav id="main-nav"><a id="main-nav-toggle" class="nav-icon"></a> <a class="main-nav-link" href="/Hexo/">Home</a> <a class="main-nav-link" href="/Hexo/archives">Archives</a></nav><nav id="sub-nav"><a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a> <a id="nav-search-btn" class="nav-icon" title="Search"></a></nav><div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://f-12.github.io/Hexo"></form></div></div></div></header><div class="outer"><section id="main"><article id="post-知其所以然-Binding-System-of-Vue" class="article article-type-post" itemscope itemprop="blogPost"><div class="article-meta"><a href="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/" class="article-date"><time datetime="2016-09-19T14:42:00.000Z" itemprop="datePublished">2016-09-19</time></a></div><div class="article-inner"><header class="article-header"><h1 class="article-title" itemprop="name">知其所以然-Binding_System_of_Vue</h1></header><div class="article-entry" itemprop="articleBody"><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li style="list-style:none"><input type="checkbox" checked> 理解Vue如何根据data生成DOM及挂载到Document对象上</li><li style="list-style:none"><input type="checkbox" checked> 理解Vue如何实现更新data属性值时自动更新DOM</li><li style="list-style:none"><input type="checkbox" checked> 理解Vue如何实现v-*指令</li></ul><h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><h2 id="DOM更新"><a href="#DOM更新" class="headerlink" title="DOM更新"></a>DOM更新</h2><p>浏览器构建DOM Tree，渲染视图，并提供DOM API更新视图。浏览器保证视图的渲染结果和DOM Tree中的数据同步。开发者经常会从服务器加载数据更新到视图上，或根据用户的交互改变视图。这些改变视图的方式可以抽象成改变视图状态数据（即数据驱动视图）。</p><p>我们一般都会使用data object保存从服务器加载到的数据或记录用户交互的状态数据，然后把这些data object里的数据同步到DOM对象的各个属性值上，触发视图的更新。</p><p>一般的做法是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  Hello,&lt;span id=&quot;name&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var name = &apos;f-12&apos;;</span><br><span class="line">  $(&apos;#name&apos;).text(name);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>name代表data object（既可能是从服务器上加载的数据，也可能是用户交互产生的状态数据），当我们把值赋给DOM的属性（使用原生DOM API或jQuery)，修改视图后，data，object就和DOM的属性值没有关系了，假如我们再次更新name，DOM属性值并不会变化，因而视图也不会变化。我们必须再次修改DOM属性才可以更新视图，即每次状态数据发生变动时我们必须手动更新视图。</p><p>手动更新DOM显得很繁琐。前端工程更加复杂，用户交互更加复杂，单页应用更加流行，产生了更多的状态数据，这些因素也凸显了手动更新DOM的缺点。</p><h2 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h2><p>Data Binding的思想就是建立data object和DOM对象之前的关系，使得我们修改data object上的属性值时自动完成DOM对象的更新。要完成这个特性，我们很自然想到了观察者模式（发布/订阅模式）</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><ul><li><strong>定义</strong></li></ul><blockquote><p>The Observer Pattern defines a one-to-many dependency between objects so that when one object changes state, all of its dependents are notified and updated automatically.</p></blockquote><ul><li><p><strong>原理</strong></p><img src="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/js_observer_pattern.png"></li><li><p><strong>Pull vs Push</strong><br>javascript有两种observer pattern的实现方式：pull和push。</p><ul><li>Push： observable状态更新时使用变更的数据作为参数调用observer注册的回调</li><li>Pull： observable状态变更时简单通知observer更新，observer使用自身持有的observable引用获取感兴趣的状态。</li></ul><p>( Vue中使用的Pull方式实现的observer pattern )</p></li><li><p><strong>用到Observer的地方</strong></p><ul><li>jQuery对象的on/trigger方法</li><li>Node里EventEmitter的on/emmit方法</li><li>DOM里EventTarget的onXXX</li></ul></li></ul><h1 id="Vue的Data-Binding"><a href="#Vue的Data-Binding" class="headerlink" title="Vue的Data Binding"></a>Vue的Data Binding</h1><img src="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/vue_binding_model.png"><blockquote><p>Reference: vuejs.org</p></blockquote><p>Web开发中比较频繁出现的场景是：</p><ul><li>有很多状态数据需要同步到DOM上（DOM操作，jQuery流行的主要因素）</li><li>多个DOM对象用到同一个状态数据，状态发生变动时需要更新所有DOM(Data Binding，MVVM流行的推动力)</li></ul><p>本次我们主要关注Vue的Data Binding实现的方式。</p><p>继续进行前，我们需要引入一个最简单的🌰。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  This is a &#123;&#123; message &#125;&#125;.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">'Hello Vue.js!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>Reference: <a href="http://vuejs.org/guide/" target="_blank" rel="noopener">vuejs.org</a></p></blockquote><p>这个代码段的效果是页面渲染时，message的值会自动同步到DOM中，当修改message时，DOM会同步更新。<br>接下来，我们来探究一下这一切是怎么发生的。</p><h2 id="import"><a href="#import" class="headerlink" title="import"></a>import</h2><p><code>new Vue()</code>之前，我们首先得引入Vue的库，我们使用ES6的<code>import</code>方式。<br><code>import Vue from &#39;vue&#39;</code>执行时，会首先找到<code>vue</code>包，然后执行里面的<code>index.js</code>代码，将其中导出的对象绑定到<code>Vue</code>这个标识符上。这一行代码完成Vue类的定义，导出一个构造函数来供使用者实例化。</p><p><code>import</code>过程体现了<code>Vue</code>的扩展能力，提现了<code>Vue</code>支持自定义<code>directive</code>，<code>filter</code>，<code>watch</code>等特性的方式。但是这个不是我们这次的关注重点，略过不讲。<br>有了Vue的构造函数，就可以用它进行实例化了。Vue实例化时做了很多事情，支撑起了Vue的<code>运行时</code>。</p><p><strong>debate</strong> <code>Vue</code>是库(<code>lib</code>)还是框架(<code>framework</code>) ?</p><h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><h3 id="el选项"><a href="#el选项" class="headerlink" title="el选项"></a><code>el</code>选项</h3><p>以下段落来自Vuejs官方文档对<code>el</code>选项的描述。</p><ul><li><p><strong>Type:</strong> <code>string | HTMLElement</code></p></li><li><p><strong>Restriction:</strong> only respected in instance creation via <code>new</code>.</p></li><li><p><strong>Details:</strong></p><p>Provide the Vue instance an existing DOM element to mount on. It can be a CSS selector string or an actual HTMLElement.</p><p>After the instance is mounted, the resolved element will be accessible as <code>vm.$el</code>.</p><p>If this option is available at instantiation, the instance will immediately enter compilation; otherwise, the user will have to explicitly call <code>vm.$mount()</code> to manually start the compilation.</p><p class="tip">The provided element merely serves as a mounting point. Unlike in Vue 1.x, the mounted element will be replaced with Vue-generated DOM in all cases. It is therefore not recommended to mount the root instance to <code>&lt;html&gt;</code> or <code>&lt;body&gt;</code>.</p></li><li><p><strong>See also:</strong> <a href="/guide/instance.html#Lifecycle-Diagram">Lifecycle Diagram</a></p></li></ul><p><code>el</code>选项提供<code>Vue</code>实例对象的挂载点，最终<code>Vue</code>实例将编译出一个<code>DOM</code>对象替换<code>el</code>对象的<code>DOM</code>。</p><p><code>el</code>的值可以是一个选择器<code>String</code>也可以是一个DOM <code>HTMLElement</code>元素，这样提供我们动态挂载Vue实例对象的能力，可以先<code>new Vue()</code>时不提供<code>el</code>值，得到<code>vm</code>对象后动态决定挂载点，调用<code>vm.$mount()</code>进行手动挂载。</p><h3 id="data选项"><a href="#data选项" class="headerlink" title="data选项"></a><code>data</code>选项</h3><p>以下段落来自Vuejs官方文档对<code>data</code>选项的描述。</p><ul><li><p><strong>Type:</strong> <code>Object | Function</code></p></li><li><p><strong>Restriction:</strong> Only accepts <code>Function</code> when used in a component definition.</p></li><li><p><strong>Details:</strong></p><p>The data object for the Vue instance. Vue will recursively convert its properties into getter/setters to make it “reactive”. <strong>The object must be plain</strong>: native objects such as browser API objects and prototype properties are ignored. A rule of thumb is that data should just be data - it is not recommended to observe objects with its own stateful behavior.</p></li></ul><p><code>data</code>选项的值可以是<code>Object</code>，一般在根实例中这样定义；可以是<code>Function</code>，组件中必须是<code>Function</code>。原因是javascript的对象是可变对象，这样做可以避免多个组件实例公用同样的对象引用。</p><p>实例化过程中会执行<code>_initData()</code>，在这个过程的最后一步是<code>observe</code>过程，将<code>data</code>选项转化为响应式数据。转化结果是<code>data</code>对象的<code>__ob__</code>保存新建的<code>Observer</code>对象，且此<code>__ob__.value</code>属性保存<code>data</code>选项对象。同时会遍历<code>data</code>选项对象的每个键值，使用ES6的<code>Object.defineProperty</code>定义其Getter和Setter。如果键值也是对象，会递归调用<code>observe</code>函数，即<code>observe(key)</code>。<br>完成<code>observe</code>调用后的<code>this.$data</code>结构<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  __ob__: &#123;</span><br><span class="line">    dep: &#123;</span><br><span class="line">      subs: []</span><br><span class="line">    &#125;</span><br><span class="line">    value: &#123;&#125; <span class="comment">//即this.$data自身</span></span><br><span class="line">    vms: [] <span class="comment">//所有持有此data对象的vm实例</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> message() &#123;&#125;</span><br><span class="line">  <span class="keyword">set</span> message(newVal) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>因为<code>observe</code>过程是在<code>_initData()</code>过程中发生，而这个过程又在<code>new Vue(options)</code>构造函数的执行中进行，所以一旦实例创建结束后，再往<code>data</code>上增加的新键值并不是响应式，因为没有经过<code>observe</code>过程转化为响应式属性。Vue解决这种场景的方式是提供了<code>Vue.$set</code>方法。</p><h3 id="Text-Node中的mustache编译"><a href="#Text-Node中的mustache编译" class="headerlink" title="Text Node中的mustache编译"></a>Text Node中的<code>mustache</code>编译</h3><h4 id="提取表达式"><a href="#提取表达式" class="headerlink" title="提取表达式"></a>提取表达式</h4><ul><li><strong>NodeType识别Text Node</strong></li><li><strong>正则表达式提取expression</strong><br>safe: <code>\{\{((?:.|\\n)+?)\}\}</code><br>unsafe: <code>\{\{\{((?:.|\\n)+?)\}\}\}</code></li><li><p><strong>创建包装getter</strong><br>创建包装的getter函数时使用<code>new Function(string)</code>完成，string是上一步提取的<code>表达式</code>的值。包装过程中一个<code>scope</code>的概念，指的是当前组件上下文，对于root组件来说是<code>undefined</code>。这也是访问没有定义的变量时console里经常报错<code>scope.xxx</code>找不到等错误的原因。</p><p>上面例子中的 <code>This is a .</code>提取后形成下面的<code>tokens</code>列表：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;<span class="attr">value</span>: <span class="string">'this is a '</span>&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    html: <span class="literal">false</span>,        <span class="comment">// 是否由unsafe模式匹配到的</span></span><br><span class="line">    oneTime: <span class="literal">false</span>,     <span class="comment">// 稍后介绍</span></span><br><span class="line">    tag: <span class="literal">true</span>,          <span class="comment">// 是否由safe或unsafe模式匹配到的</span></span><br><span class="line">    value: <span class="string">'message'</span>    <span class="comment">// 匹配到的文本值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;<span class="attr">value</span>: <span class="string">'.'</span>&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>Text中的每一个<code>mustache</code>匹配到的文本将生成类似列表中第二个对象的一个token对象。其他token是由其余简单文本生成的。</p></li></ul><h4 id="创建Text-Node"><a href="#创建Text-Node" class="headerlink" title="创建Text Node"></a>创建Text Node</h4><p>根据每个<code>tag</code>属性为true的token使用<code>function processTextToken (token, options) {}</code>处理，创建对应的Text Node对象并加入到一个新创建的<code>DocumentFragment</code>对象中。此过程中将进一步对token标记<code>descriptor</code>。<code>mustache</code>内部可能包含的过滤器调用也是在<code>descriptor</code>中标记。<code>token.tag</code>为<code>false</code>直接生成简单的Text Node。<br>此时的token结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  html: <span class="literal">false</span>,</span><br><span class="line">  oneTime: <span class="literal">false</span>,</span><br><span class="line">  tag: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">'message'</span>,</span><br><span class="line">  descriptor: &#123;</span><br><span class="line">    name: <span class="string">'text'</span>,           <span class="comment">// 表示当前token代表一个text node</span></span><br><span class="line">    <span class="comment">// directives/public/text预先定义的directive</span></span><br><span class="line">    def: &#123;</span><br><span class="line">      bind() &#123;&#125;,</span><br><span class="line">      update() &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    expression: <span class="string">'message'</span>,  <span class="comment">// 由token中的值生成的表达式</span></span><br><span class="line">    filters: <span class="literal">undefined</span>      <span class="comment">// 可能包含的过滤器调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>递归编译每个DOM节点时，会对每个node生成对应的linker函数，这些linker会最终组合成一个linker。编译过程结束后，调用这个函数会开始link过程。代码概括为<code>compile(el, options)(this, el)</code>。link过程会递归调用所有的linker。</p><p>每个linker调用会创建一个<code>Directive</code>对象并添加到Vue实例的<code>_directives</code>数组中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this._directives.push(</span><br><span class="line">  new Directive(</span><br><span class="line">    descriptor, // 编译过程中token中标记的discriptor</span><br><span class="line">    this,       // 当前Vue实例</span><br><span class="line">    node,       // 创建的对应DOM node对象</span><br><span class="line">    host,       // 宿主DOM node</span><br><span class="line">    scope,</span><br><span class="line">    frag</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>当所有的<code>Directive</code>对象添加到Vue实例的<code>_directives</code>数组中后，会遍历新增加的所有<code>Directive</code>，调用其上的<code>_bind</code>方法。（由于Vue提供了通过自定义<code>Directive</code>复用代码的方式，这里为了防止在实例化过程中调用到这些<code>Directive</code>的<code>_bind</code>方法，Vue通个<code>Directive.discriptor.priority</code>中保存自身优先级， link过程中创建的<code>Directive</code>对象都具有默认优先级。然后遍历前会现根据优先级排序。）</p><p>如下代码所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalDirCount = vm._directives.length</span><br><span class="line">linker()</span><br><span class="line"><span class="keyword">var</span> dirs = vm._directives.slice(originalDirCount)</span><br><span class="line">sortDirectives(dirs)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = dirs.length; i &lt; l; i++) &#123;</span><br><span class="line">  dirs[i]._bind()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>至此link过程完成了一半，继续进行下一半前，我们需要引入<code>Directive</code>类和<code>Watcher</code>类。</p><p>一个directive对象将DOM Element和data中的属性链接起来，并在内部注册一个Watchre对象，在data属性更新时调用update函数更新DOM对象。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部结构如下：</span></span><br><span class="line">&#123;</span><br><span class="line">  vm: <span class="built_in">Object</span>,           <span class="comment">// Vue实例</span></span><br><span class="line">  el: <span class="built_in">Object</span>,           <span class="comment">// 根DOM</span></span><br><span class="line">  descriptor: <span class="built_in">Object</span>,   <span class="comment">// discriptor</span></span><br><span class="line">  name: <span class="built_in">String</span>,         <span class="comment">// discriptor.name</span></span><br><span class="line">  expression: <span class="built_in">Object</span>,   <span class="comment">// discriptor.expression</span></span><br><span class="line">  arg: <span class="built_in">Object</span>,          <span class="comment">// discriptor.arg</span></span><br><span class="line">  modifiers: [],    <span class="comment">// discriptor.modifiers</span></span><br><span class="line">  filters: [],      <span class="comment">// discriptor.filters</span></span><br><span class="line">  literal: ,</span><br><span class="line">  _locked: <span class="built_in">Boolean</span>, <span class="comment">//</span></span><br><span class="line">  _bound: <span class="built_in">Boolean</span>,   <span class="comment">// intial bind后为true</span></span><br><span class="line">  _listeners: [], <span class="comment">//</span></span><br><span class="line">  _host: <span class="built_in">Object</span>,        <span class="comment">// context信息</span></span><br><span class="line">  _scope: <span class="built_in">Object</span>,     <span class="comment">// context信息</span></span><br><span class="line">  _frag: <span class="built_in">Object</span>     <span class="comment">// context信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Directive</span> (<span class="params">descriptor, vm, el, host, scope, frag</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Directive.prototype._bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 其他一些方法 */</span></span><br></pre></td></tr></table></figure><p></p><p>一个Watcher对象封装一个表达式，收集该表达式的依赖项，在表达式的值发生变化时调用回调函数。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 内部数据结构如下</span><br><span class="line">&#123;</span><br><span class="line">  vm： Vue, // Vue实例</span><br><span class="line">  expression: String | Function,   // 被封装的表达式，来自discriptor.expression</span><br><span class="line">  cb: Function,</span><br><span class="line">  id: Number,                      // 内部自增全局变量uid，批处理使用</span><br><span class="line">  active: Boolean,</span><br><span class="line">  dirty: Boolean,                  // lazy watchers标志量</span><br><span class="line">  deps: [],                        //</span><br><span class="line">  newDeps: [],</span><br><span class="line">  depIds: Set,</span><br><span class="line">  newDepIds: Set,</span><br><span class="line">  prevError: null, // for async error stacks</span><br><span class="line">  getter: Function,</span><br><span class="line">  setter: Function,</span><br><span class="line">  queued: Boolean, // for avoiding false triggers for deep and Array</span><br><span class="line">  shallow: Boolean // for avoiding false triggers for deep and Array</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * @constructor</span><br><span class="line"> */</span><br><span class="line">export default function Watcher (vm, expOrFn, cb, options) &#123;&#125;</span><br><span class="line"></span><br><span class="line">Watcher.prototype.get = function() &#123;&#125;           // 计算expression的值并重新计算依赖</span><br><span class="line">Watcher.prototype.set = function(value) &#123;&#125;      // 先应用可能的filter然后设置对应属性值</span><br><span class="line">Watcher.prototype.beforeGet = function() &#123;&#125;     // 设置全局Dep.target为当前Watcher实例，准备收集依赖</span><br><span class="line">Watcher.prototype.afterGet = function() &#123;&#125;      //</span><br><span class="line">Watcher.prototype.update = function(shallow) &#123;&#125; // Subscriber接口，被Publisher调用，Vue的Publisher由Dep实现</span><br><span class="line">Watcher.prototype.run = function() &#123;&#125;           // Batch job接口，被batcher调用</span><br><span class="line">Watcher.prototype.evalute = function() &#123;&#125;</span><br><span class="line">Watcher.prototype.addDep = function() &#123;&#125;        //</span><br><span class="line">Watcher.prototype.depend = function() &#123;&#125;        // 遍历调用deps上的depend</span><br><span class="line">Watcher.prototype.teardown = function() &#123;&#125;      // 清楚一个watcher，遍历调用deps里的removeSub()移除对其的订阅</span><br></pre></td></tr></table></figure><p></p><p>在directive对象bind的过程中， 会删除<code>el</code> DOM上声明的v-*指令，然后将discriptor上定义的属性mixin到自身，并调用<code>discriptor.bind()</code>完成initial bind。<br>然后会new一个Watcher对象，并初始化更新DOM，将data上的初始化值更新到DOM上（这里需要例外处理v-model，将input的inline value回写到data中）。</p><p>此时我们生成的<code>Directive</code>和<code>Watcher</code>对象如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    _bound: true,</span><br><span class="line">    _frag: undefined,</span><br><span class="line">    _host: undefined,</span><br><span class="line">    _listeners: null,</span><br><span class="line">    _locked: false,</span><br><span class="line">    _scope: undefined,</span><br><span class="line">    _update() &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    _watcher: &#123;                   // 每个directive对象都会持有一个watcher对象</span><br><span class="line">        id: 1,</span><br><span class="line">        active: true,</span><br><span class="line">        cb(val, oldVal) &#123;&#125;,</span><br><span class="line">        deep: undefined,</span><br><span class="line">        depIds: [1],</span><br><span class="line">        deps: [Watcher],</span><br><span class="line">        dirty: undefined,</span><br><span class="line">        expression: &quot;message&quot;,</span><br><span class="line">        filters: undefined,</span><br><span class="line">        getter() &#123;&#125;</span><br><span class="line">        newDepIds: [],</span><br><span class="line">        newDeps: [],</span><br><span class="line">        postProcess: null,</span><br><span class="line">        preProcess: null,</span><br><span class="line">        prevError: null,</span><br><span class="line">        queued: false,</span><br><span class="line">        scope: undefined,</span><br><span class="line">        setter: undefined,</span><br><span class="line">        shallow: false,</span><br><span class="line">        twoWay: undefined,</span><br><span class="line">        value: &quot;hello world&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    arg: undefined,</span><br><span class="line">    attr: &quot;data&quot;,               // 因为是data选项中定义的属性，所以值为data，如果只是简单text则为textContent</span><br><span class="line">    descriptor: Object,         // token.descriptor</span><br><span class="line">    bind: bind(),               // token.descriptor.bind</span><br><span class="line">    update(value) &#123;&#125;,           // token.descriptor.update</span><br><span class="line">    el: Text,                   // DOM中的Text类实例</span><br><span class="line">    expression: &quot;message&quot;,</span><br><span class="line">    filters: undefined,</span><br><span class="line">    literal: undefined,</span><br><span class="line">    modifiers: undefined,</span><br><span class="line">    name: &quot;text&quot;,               // 标明此directive对象注册时key为text，自定义directive时将由Vue.directive(name, Object)提供name</span><br><span class="line">    vm : Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="依赖系统"><a href="#依赖系统" class="headerlink" title="依赖系统"></a>依赖系统</h4><p>前面讲解link过程时，提到了收集依赖。所以一并讲解下Vue的依赖系统。依赖系统本质上是一个发布-订阅模式的实现。<code>Watcher</code>实现订阅者职责，<code>Dep</code>实现发布者职责，发布的内容是自身值的改变，<code>Watcher</code>对应的响应是使用依赖重新计算自己的值并调用回调函数。</p><p>为此引入<code>Dep</code>类。<br>一个Dep对象是一个发布者，可以被多个directive（实际上是directive里面的watcher）订阅。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部结构</span></span><br><span class="line">&#123;</span><br><span class="line">  id: <span class="built_in">Number</span>,      <span class="comment">// 自增的uid</span></span><br><span class="line">  subs: []         <span class="comment">// 实现了update方法的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Dep</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Dep.target        <span class="comment">// 全局变量，标志当前收集依赖的Watcher对象</span></span><br><span class="line"></span><br><span class="line">Dep.prototyp.addSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 增加订阅者</span></span><br><span class="line">Dep.prototyp.removeSub = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 移除订阅者</span></span><br><span class="line">Dep.prototyp.depend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 将自身增加当Dep.target的依赖中</span></span><br><span class="line">Dep.prototyp.notify   = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;        <span class="comment">// 遍历调用subs里对象的update方法，即发布更新</span></span><br></pre></td></tr></table></figure><p></p><h4 id="Binding流程"><a href="#Binding流程" class="headerlink" title="Binding流程"></a>Binding流程</h4><p>下面使用流程图总结一下这个过程中的行为。<br><img src="/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/vue_binding_sequence.png"></p><p><strong>Workshop</strong> debug <code>vm.message = &#39;Goodbye World&#39;</code>时的执行时序</p><h1 id="指令处理"><a href="#指令处理" class="headerlink" title="指令处理"></a>指令处理</h1><p><code>Vue</code>会根据写在<code>template</code>里的模板编译出<code>DOM</code>对象。<code>template</code>模板本身是<code>html</code>代码，<code>Vue</code>的功能通过写在html代码里的指令，<code>mustache</code>代码以及自定义<code>tag</code>实现。<br>模板的编译本质上是手动创建<code>DOM</code>树的过程。Vue中指令主要有<code>v-*</code>指令以及<code></code>指令，还有<code>number</code>, <code>transition</code>, <code>keep-alive</code>等属性指令，还有<code>&lt;component&gt;&lt;/component&gt;</code>等元素指令，还有自定义组件标签指令。</p><h2 id="Terminal指令"><a href="#Terminal指令" class="headerlink" title="Terminal指令"></a>Terminal指令</h2><h3 id="v-if指令"><a href="#v-if指令" class="headerlink" title="v-if指令"></a><code>v-if</code>指令</h3><h4 id="v-if-compile"><a href="#v-if-compile" class="headerlink" title="v-if compile"></a><code>v-if</code> <strong>compile</strong></h4><p>开始前，我们需要小小修改下实例代码，如下。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">  This is a <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">"show"</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: <span class="literal">true</span>,</span><br><span class="line">    message: <span class="string">'Hello Vue.js!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结合之前讲的过程，直接从compile阶段开始。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compileElement</span>(<span class="params">el, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// preprocess textareas.</span></span><br><span class="line">  <span class="comment">// textarea treats its text content as the initial value.</span></span><br><span class="line">  <span class="comment">// just bind it as an attr directive for value.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> linkFn;</span><br><span class="line">  <span class="keyword">var</span> hasAttrs = el.hasAttributes();</span><br><span class="line">  <span class="keyword">var</span> attrs = hasAttrs &amp;&amp; toArray(el.attributes);</span><br><span class="line">  <span class="comment">// check terminal directives (for &amp; if)</span></span><br><span class="line">  <span class="keyword">if</span> (hasAttrs) &#123;</span><br><span class="line">    linkFn = checkTerminalDirectives(el, attrs, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check element directives</span></span><br><span class="line">  <span class="keyword">if</span> (!linkFn) &#123;</span><br><span class="line">    linkFn = checkElementDirectives(el, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check component</span></span><br><span class="line">  <span class="keyword">if</span> (!linkFn) &#123;</span><br><span class="line">    linkFn = checkComponent(el, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// normal directives</span></span><br><span class="line">  <span class="keyword">if</span> (!linkFn &amp;&amp; hasAttrs) &#123;</span><br><span class="line">    linkFn = compileDirectives(attrs, options);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> linkFn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码会从<code>el</code>选项指示的挂载点<code>div#app</code>开始，可以断定，在实例代码中，会执行两次，第一次针对<code>div#app</code>, 第二次针对<code>span</code>。跳过对<code>div#app</code>的编译过程，直接看对<code>span</code>执行的过程。<br>代码标明对指令的处理主要经过了两个过程：check和compile。其中check会分别检查<strong>terminal directive</strong>，<strong>element directive</strong>， <strong>component</strong>。其中<strong>terminal directive</strong>指的是<code>v-*</code>指令，<strong>element directive</strong>指类似<code>&lt;component&gt;&lt;/component&gt;</code>这样的自定义标签指令，<strong>component</strong>指令指自Vue组件。<br>实例代码比较简单所以只会执行<code>checkTerminalDirectives</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTerminalDirectives</span>(<span class="params">el, attrs, options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// skip v-pre</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// skip v-else block, but only if following v-if</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">var</span> attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, j = attrs.length; i &lt; j; i++) &#123;</span><br><span class="line">    attr = attrs[i];</span><br><span class="line">    name = attr.name.replace(modifierRE, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (matched = name.match(dirAttrRE)) &#123;</span><br><span class="line">      def = resolveAsset(options, <span class="string">'directives'</span>, matched[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span> (def &amp;&amp; def.terminal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) &gt; termDef.priority) &#123;</span><br><span class="line">          termDef = def;</span><br><span class="line">          rawName = attr.name;</span><br><span class="line">          modifiers = parseModifiers(attr.name);</span><br><span class="line">          value = attr.value;</span><br><span class="line">          dirName = matched[<span class="number">1</span>];</span><br><span class="line">          arg = matched[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (termDef) &#123;</span><br><span class="line">    <span class="keyword">return</span> makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程会遍历element attribute node列表，<code>name.match(dirAttrRE)</code>来匹配到需要处理的<code>v-*</code>指令。这里<code>dirAttrRE</code>是正则表达式：<code>/^v-([^:]+)(?:$|:(.*)$)/</code>。<br>对每个特定的terminal directive，<code>def = resolveAsset(options, &#39;directives&#39;, matched[1])</code>获取内置的指令<code>def</code>对象, 实例中即为<code>def = resolveAsset(options, &#39;directives&#39;, &#39;if&#39;)</code>。Terminal directive 的<code>def</code>对象在’src/directives/public/‘目录下定义，每个<code>def</code>对象定义了<code>bind</code>过程中调用的接口方法, 如下所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  priority: DEFAULT_TERMINAL_PRIORITY,</span><br><span class="line">  terminal: <span class="literal">true</span>,</span><br><span class="line">  bind() &#123;&#125;,</span><br><span class="line">  update(value) &#123;&#125;,</span><br><span class="line">  insert() &#123;&#125;,</span><br><span class="line">  remove() &#123;&#125;,</span><br><span class="line">  updateRef() &#123;&#125;,</span><br><span class="line">  unbind() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个<code>def</code>对象，讲解<code>Text Node</code>编译过程中也涉及到了，当时只有<code>bind</code>和<code>update</code>方法。</p><h4 id="v-if-link"><a href="#v-if-link" class="headerlink" title="v-if link"></a><code>v-if</code> link</h4><p>编译完成后，将进行<code>link</code>过程。此过程和Text Node的link过程基本一致，最终会执行如下代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._directives.push(</span><br><span class="line">  <span class="keyword">new</span> Directive(</span><br><span class="line">    descriptor, <span class="comment">// 编译过程中token中标记的discriptor</span></span><br><span class="line">    <span class="keyword">this</span>,       <span class="comment">// 当前Vue实例</span></span><br><span class="line">    node,       <span class="comment">// 创建的对应DOM node对象</span></span><br><span class="line">    host,       <span class="comment">// 宿主DOM node</span></span><br><span class="line">    scope,</span><br><span class="line">    frag</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// descriptor:</span></span><br><span class="line">&#123;</span><br><span class="line">  arg: <span class="literal">undefined</span>,</span><br><span class="line">  attr: <span class="string">'v-if'</span>,</span><br><span class="line">  def: &#123;&#125;,              <span class="comment">// 上文有详述，略去细节</span></span><br><span class="line">  expression: <span class="string">'show'</span>,</span><br><span class="line">  filters: <span class="literal">undefined</span>,</span><br><span class="line">  modifiers: &#123;&#125;         <span class="comment">// 空对象</span></span><br><span class="line">  name: <span class="string">'if'</span>,</span><br><span class="line">  raw: <span class="string">'show'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node: &lt;span v-if="show"&gt; &#123;&#123; show &#125;&#125;&lt;/span&gt;</span></span><br></pre></td></tr></table></figure><p></p><h4 id="v-if-bind"><a href="#v-if-bind" class="headerlink" title="v-if bind"></a><code>v-if</code> <strong>bind</strong></h4><p>上面<strong>link</strong>过程结束后，会开始<strong>bind</strong>过程，具体请见上一节。<code>v-if</code>的<strong>bind</strong>过程中多态部分是执行<code>v-if def</code>对象上的<code>bind() {}</code>的过程。如下代码所示：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> el = <span class="keyword">this</span>.el;</span><br><span class="line">    <span class="keyword">if</span> (!el.__vue__) &#123;</span><br><span class="line">      <span class="comment">// check else block</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// check main block</span></span><br><span class="line">      <span class="keyword">this</span>.anchor = createAnchor(<span class="string">'v-if'</span>);</span><br><span class="line">      replace(el, <span class="keyword">this</span>.anchor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// debug info</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个过程其实就是简单的创建了一个空白的Text Node替换了<code>&lt;span&gt;&lt;/span&gt;</code>DOM元素，所以页面中开始出现<code></code>会出现短暂地变成空白。但是<code>createAnchor</code>的设计意图可以深究一下，目前所知就是为了和后面的<strong>初始化update</strong>结合使用，<code>update</code>环节会获取<code>show</code>的值，根据值计算节点, 调用<code>def.insert</code>方法，将正式DOM插入到<code>createAnchor</code>所在位置。</p><p><strong>bind</strong>的其他过程同上节所示。</p><h3 id="v-for指令"><a href="#v-for指令" class="headerlink" title="v-for指令"></a><code>v-for</code>指令</h3><p><code>v-for</code>指令的<strong>compile</strong>和<strong>link</strong>过程和<code>v-if</code>指令大致相同，区别仅在<strong>bind</strong>过程调用<code>def.bind</code>和<code>def.update</code>上。<br>但是<code>v--for</code>指令有性能优化的问题要解决，比如列表更新时如何最少化DOM操作，如何进行实例缓存等。<br>Vue使用<code>diff</code>算法解决列表渲染中列表动态变化的问题。</p><h3 id="其他v-指令"><a href="#其他v-指令" class="headerlink" title="其他v-*指令"></a>其他<code>v-*</code>指令</h3><p>类似的处理，但是涉及不同情况的细节处理。可以细看<code>src/directive/public/</code>目录下的代码。</p><h2 id="Element指令"><a href="#Element指令" class="headerlink" title="Element指令"></a><code>Element</code>指令</h2><h3 id="lt-component-gt-lt-component-gt-指令"><a href="#lt-component-gt-lt-component-gt-指令" class="headerlink" title="&lt;component&gt;&lt;/component&gt;指令"></a><code>&lt;component&gt;&lt;/component&gt;</code>指令</h3><h3 id="lt-slot-gt-lt-slot-gt-指令"><a href="#lt-slot-gt-lt-slot-gt-指令" class="headerlink" title="&lt;slot&gt;&lt;/slot&gt;指令"></a><code>&lt;slot&gt;&lt;/slot&gt;</code>指令</h3><p>这个也很简单，处理node attribute时检查slot属性，然后替换父节点内的name匹配的slot节<br>点即可。</p><h2 id="Custom-Component指令"><a href="#Custom-Component指令" class="headerlink" title="Custom Component指令"></a><code>Custom Component</code>指令</h2><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://github.com/banama/aboutVue" target="_blank" rel="noopener">banama/abountVue</a></li><li><a href="http://jiongks.name/blog/vue-code-review/" target="_blank" rel="noopener">jinks</a></li></ul></div><footer class="article-footer"><a data-url="https://f-12.github.io/Hexo/2016/09/19/知其所以然-Binding-System-of-Vue/" data-id="cjvj9vo8i0027qex0u6gk8jg5" class="article-share-link">Share</a><ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Javascript/">Javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Vue/">Vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/Hexo/tags/Web/">Web</a></li></ul></footer></div><nav id="article-nav"><a href="/Hexo/2017/09/25/webpack的插件体系结构/" id="article-nav-newer" class="article-nav-link-wrap"><strong class="article-nav-caption">Newer</strong><div class="article-nav-title">webpack的插件体系结构</div></a></nav></article></section><aside id="sidebar"><div class="widget-wrap"><h3 class="widget-title">Tags</h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/ALert/">ALert</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Javascript/">Javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Lock/">Lock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Monitoring/">Monitoring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Prometheus/">Prometheus</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/SpringBootAdmin/">SpringBootAdmin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/fork/">fork</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/join/">join</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/告警/">告警</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/并发/">并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/微服务/">微服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/插件体系/">插件体系</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/源码分析/">源码分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/监控/">监控</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/线程/">线程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/线程池/">线程池</a></li><li class="tag-list-item"><a class="tag-list-link" href="/Hexo/tags/锁/">锁</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Tag Cloud</h3><div class="widget tagcloud"><a href="/Hexo/tags/ALert/" style="font-size:10px">ALert</a> <a href="/Hexo/tags/Java/" style="font-size:17.5px">Java</a> <a href="/Hexo/tags/Javascript/" style="font-size:10px">Javascript</a> <a href="/Hexo/tags/Lock/" style="font-size:10px">Lock</a> <a href="/Hexo/tags/Monitoring/" style="font-size:17.5px">Monitoring</a> <a href="/Hexo/tags/Prometheus/" style="font-size:12.5px">Prometheus</a> <a href="/Hexo/tags/RabbitMQ/" style="font-size:10px">RabbitMQ</a> <a href="/Hexo/tags/Spring/" style="font-size:10px">Spring</a> <a href="/Hexo/tags/SpringBootAdmin/" style="font-size:10px">SpringBootAdmin</a> <a href="/Hexo/tags/Vue/" style="font-size:10px">Vue</a> <a href="/Hexo/tags/Web/" style="font-size:10px">Web</a> <a href="/Hexo/tags/fork/" style="font-size:10px">fork</a> <a href="/Hexo/tags/javascript/" style="font-size:10px">javascript</a> <a href="/Hexo/tags/join/" style="font-size:10px">join</a> <a href="/Hexo/tags/webpack/" style="font-size:10px">webpack</a> <a href="/Hexo/tags/告警/" style="font-size:10px">告警</a> <a href="/Hexo/tags/并发/" style="font-size:12.5px">并发</a> <a href="/Hexo/tags/微服务/" style="font-size:20px">微服务</a> <a href="/Hexo/tags/插件体系/" style="font-size:10px">插件体系</a> <a href="/Hexo/tags/源码分析/" style="font-size:10px">源码分析</a> <a href="/Hexo/tags/监控/" style="font-size:15px">监控</a> <a href="/Hexo/tags/线程/" style="font-size:17.5px">线程</a> <a href="/Hexo/tags/线程池/" style="font-size:10px">线程池</a> <a href="/Hexo/tags/锁/" style="font-size:10px">锁</a></div></div><div class="widget-wrap"><h3 class="widget-title">Archives</h3><div class="widget"><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/Hexo/archives/2016/09/">September 2016</a></li></ul></div></div><div class="widget-wrap"><h3 class="widget-title">Recent Posts</h3><div class="widget"><ul><li><a href="/Hexo/2019/05/11/砖瓦集——Java并发编程演变史/">砖瓦集——Java并发编程演变史</a></li><li><a href="/Hexo/2019/05/11/砖瓦集——Java-Fork-Join/">砖瓦集——Java Fork/Join</a></li><li><a href="/Hexo/2019/05/11/砖瓦集——Java-Lock/">砖瓦集——Java Lock</a></li><li><a href="/Hexo/2019/05/10/砖瓦集——Java-Thread-Pool/">砖瓦集——Java Thread Pool</a></li><li><a href="/Hexo/2019/05/10/砖瓦集——Java-Thread/">砖瓦集——Java Thread</a></li></ul></div></div></aside></div><footer id="footer"><div class="outer"><div id="footer-info" class="inner">&copy; 2019 F-12<br>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></div></div></footer></div><nav id="mobile-nav"><a href="/Hexo/" class="mobile-nav-link">Home</a> <a href="/Hexo/archives" class="mobile-nav-link">Archives</a></nav><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><link rel="stylesheet" href="/Hexo/fancybox/jquery.fancybox.css"><script src="/Hexo/fancybox/jquery.fancybox.pack.js"></script><script src="/Hexo/js/script.js"></script></div></body>