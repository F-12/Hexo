title: 2019-05-13 项目小结
toc: true
thumbnail: /images/banner.jpg
tags:
  - 总结
nanoid: ER1pXGHCP7o70vP1RhDnl
date: 2019-05-13 23:45:52
---

本文记录2018-08 ～ 2019-06 后端开发项目总结。

<!-- more -->

# 项目列表
- Eunomia
- OSB
- 监控平台

## Eunomia
微服务编排中间件。

### 技术选型
- RabbitMQ用来做可靠消息队列
- MongoDB存储workflow定义
- Redis缓存，需要加锁的地方使用Redis做分布式锁

### 开发职责
- 根据 solution architecture 的要求给出技术方案
- 领域模型设计
- 消息通信模型设计
- 类图设计、时序图
- 执行引擎模块代码开发
- 存储层模块代码开发

### 功能介绍
1. 流程建模
1. 流程定义存储
1. 流程实例化
1. 流程执行
1. 结果返回

**流程建模**  

前端h5应用，画图保存为json格式。json中定义 start、end、sequence、task 四种类型对象。

**流程定义存储**

使用mongo存储，一个流程存储为flow collection里的document。 
每个流程定义存在唯一id表示flow的定义id。

**流程实例化**  

有应用层服务接口触发。  
接口发出的 trigger event header 中携带 flow definition id。  
Eunomia 根据flow definition id 查找到流程进行实例化。  

**流程查找**

redis里存在一个hash，key为flow definition id，value为flow的active状态。1为可用，0为失效。空为未缓存。

flow defintion的json对象存储在flow_definition_namespace:<ID>

查询的流程为有效缓存用缓存，没有缓存从mongodb中加载并更新到缓存。

**流程更新**

1. 先写mongodb
1. 写成功后，将缓存中的流程写为失效
1. 更新缓存里的json对象
1. 更改redis里存储flow active hash里对应flow id的active状态

**流程执行**

串行节点：接到一个event取出 header里的task id， 根据 sequence 找到下一个节点发送执行的command

并行节点：接到一个event取出 task id，根据 sequece 找到多个节点，并行执行

合并节点：并行执行的路径在合并节点处等待每个并行路径执行结束

**如何处理并行节点**
并行比较简单，只需要将上一步数据copy一份对每个节点发送对应的command

**多实例时如何处理合并节点**

处理合并节点需要考虑如下问题：
- 如何判断继续下一步执行
- 多节点情况下，如何确保流程不会中断
- 多节点情况下，如何确保流程不会重复执行

redis中对每个flow instance定义了一个hash，hash 的 key 为 task id，value 为 task 执行结果。  

执行合并节点逻辑：
1. 检查当前合并节点是否已经在执行，若正在执行，什么也不做
2. 若没有执行，检查合并节点的所有前置节点的执行结果是否存在
3. 若没有全部存在，则没50ms后重新检测
4. 若全部存在，设置当前合并节点为正在执行
5. 设置成功，则找到合并节点下一节点，继续执行
6. 设置失败，则什么也不做

问题1: 先检查是否在执行，是为了防止重复执行后续流程，确保经过合并后只有一个执行路径
问题2: 检查所有前置节点结果，是为了决定当前分支流程是否全部执行结束
问题3: 睡50ms后重新检测是为了防止并发导致每个节点都放弃执行流程导致流程中断执行
问题4: 设置当前合并节点为正在执行，利用redis的 setnx 操作，保证只有一个节点设置成功，其他设置失败，确保合并后也只有一个执行路径


**结果返回**

client侧会监听的replay channel的消息。

reply channel 使用了 rabbitmq fanout exchange，实现对同一个服务不同实例的事件广播。

服务实例接受到 reply 消息，会根据message 里的 trasactionId找到一个AysncTask对象进行唤醒（notify）。

唤醒后，回复响应给请求端。


### 性能指标

- 5 ms/事件

### 亮点
**支持两种请求模式**

异步模式和同步模式。

异步模式在请求进来后，生成唯一transaction id，请求存储后，后续流程可以异步继续执行。

同步模式在请求进来后，生成transaction id，请求存储后，会提交一个AsyncTask，然后wait，等待被唤醒。
设置超时时间60s。超时则返回超时错误码和transaction id。


**支持CQRS**

流程定义时可以对查询服务发送command，通过command message携带数据给query service。query service将数据转换为自己的结构存储，支持后续查询服务。

支持事务型应用和查询类服务分离。

支持前端接口类应用和后台业务类服务隔离。

**支持saga**

实现了saga，分布式事务
每个流程开始时，生成全局事务id。  
每个task command中包含局部事务id。  
根据task执行结果决定是否回滚事务。  
回滚按照存储的command的逆序时间发送对应command的abort command。

对于外部服务，通过调用与之对应的取消操作。

**支持横向扩展**

流程状态类数据均写入redis，Eunomia本身只进行计算。

因而执行性能比较好。

1G CPU 1G内存的情况下，单个节点支持80无压力

平均长度为6的流程，100% CPU 平均每个 trasaction 耗时 200ms多

每个 message 处理时间大约 10ms。

## OSB
### 项目介绍
车联网项目。

三种类型终端：车载终端、车主app、车内控制器

功能包括：
- 在线服务预约：保养预约、洗车服务、修车服务、零件购买、代驾服务
- 车控检测：车辆健康监控及提醒，比如空调状态，车灯状况

业务及系统指标
- 600w 汽车
- 请求量高峰期，3000/min
- 压测，1G CPU，1G内存，单节点，可支持50并发，支持横向扩展

### 技术选型
- 部署在pcf PasS平台
- spring cloud 
- RabbitMQ做消息队列
- Redis
- Azure SQL Server

### 开发职责
- 领域模型设计
- 骨架代码开发
- 分拆开发任务，指导其他三个成员，进度管控
- review代码

### 项目亮点
- OSB关于领域驱动设计方法论的实践
- 数据迁移方案


DDD：
- 核心在于统一概念，建立深层领域模型
- 战术层面的模式：Aggregate root、Entity、Value、Repository、Factory、Service
- 战略层面的模式：限界上下文、Context Map、大型结构


# 技术储备

## Redis

### 分布式锁

RedLock
Redisson

### 5种数据结构

### 网络多路复用模型

## RabbitMQ
### AMQP协议

### 四种Exchange





